/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * Partner OpenAPI Specification V2
 * OpenAPI spec version: 2.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { customInstance } from './axios-instance';

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;

export type AccountsRequestAssociateType = typeof AccountsRequestAssociateType[keyof typeof AccountsRequestAssociateType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountsRequestAssociateType = {
  ASSOCIATE_TYPE_NOT_SET: 'ASSOCIATE_TYPE_NOT_SET',
  NOT_ASSOCIATE: 'NOT_ASSOCIATE',
  POOL: 'POOL',
  COMMISSION: 'COMMISSION',
} as const;

export interface BillingAddDocumentBody {
  documentId?: string;
  name?: string;
}

export interface CounterpartyProfileAdditionalInfo {
  type?: CounterpartyCPProfileType;
  businessLine?: CounterpartyCPLineOfBusiness;
  relationship?: CounterpartyCPRelationshipToCustomer;
}

export interface CustomerDocumentUpdateBody {
  docType?: ApplicationDocumentType;
  /** Document Description */
  info?: string;
}

export interface CustomerSetApplicationBody {
  individual?: CustomerIndividualApplication;
  corporate?: CustomerCorporateApplication;
}

export type FilterCondition = typeof FilterCondition[keyof typeof FilterCondition];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FilterCondition = {
  LIKE: 'LIKE',
  LIKEG: 'LIKEG',
  LIKEL: 'LIKEL',
  EQUAL: 'EQUAL',
  GREAT: 'GREAT',
  LESS: 'LESS',
  GREAT_EQUAL: 'GREAT_EQUAL',
  LESS_EQUAL: 'LESS_EQUAL',
  IN: 'IN',
  NOTEQUAL: 'NOTEQUAL',
  BETWEEN: 'BETWEEN',
  IS: 'IS',
  ISNOT: 'ISNOT',
  JSON_CONTAINS: 'JSON_CONTAINS',
  JSON_EXTRACT: 'JSON_EXTRACT',
} as const;

export type FilterOperator = typeof FilterOperator[keyof typeof FilterOperator];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FilterOperator = {
  O_AND: 'O_AND',
  O_OR: 'O_OR',
} as const;

export interface MessagesUpdateTemplateBody {
  typeId: number;
  subject: string;
  title: string;
  content?: string;
  button?: string;
  link?: string;
  delay?: string;
  isActive?: boolean;
  showTime?: string;
  triggers?: V1Trigger[];
}

export type SearchRequestSort = typeof SearchRequestSort[keyof typeof SearchRequestSort];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SearchRequestSort = {
  ASC: 'ASC',
  DESC: 'DESC',
} as const;

export interface UpdatePartnerRequestLogo {
  id?: string;
  name?: string;
}

export interface UsersAddRelationClientBody {
  customerId?: string;
  isOwner?: boolean;
}

export interface AccountAccountBalance {
  balance?: Accountsv1Balance;
  hold?: Accountsv1Balance;
}

export interface AccountAccountCustomer {
  id?: string;
  name?: string;
  email?: string;
  phone?: string;
  status?: UsersClientStatus;
}

export interface AccountAccountResponse {
  item?: V2accountAccount;
}

export type AccountAccountsRequestBalance = typeof AccountAccountsRequestBalance[keyof typeof AccountAccountsRequestBalance];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountAccountsRequestBalance = {
  NOTSET: 'NOTSET',
  NEGATIVE: 'NEGATIVE',
  POSITIVE: 'POSITIVE',
  ZERO: 'ZERO',
} as const;

export type AccountAccountsRequestStatus = typeof AccountAccountsRequestStatus[keyof typeof AccountAccountsRequestStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountAccountsRequestStatus = {
  ACCOUNT_STATUS_NOTSET: 'ACCOUNT_STATUS_NOTSET',
  NEW: 'NEW',
  PRE_MODERATION: 'PRE_MODERATION',
  MODERATION: 'MODERATION',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED',
  BANNED: 'BANNED',
  PROCESSING: 'PROCESSING',
} as const;

export interface AccountAccountsResponse {
  items?: V2accountAccount[];
  meta?: V2ListMeta;
}

export interface AccountAccountsUpdateAccountBody {
  readonly customerId: string;
  name?: string;
  currencyCode?: string;
  isDefault?: boolean;
  status?: Delosaccountsv1AccountStatus;
}

export interface AccountCreateAccountRequest {
  customerId?: string;
  name?: string;
  currencyCode: string;
}

export interface Accountsv1Balance {
  money?: TypeMoney;
  default?: TypeMoney;
}

/**
 * Message that represents an arbitrary HTTP body. It should only be used for
payload formats that can't be represented as JSON, such as raw binary or
an HTML page.


This message can be used both in streaming and non-streaming API methods in
the request as well as the response.

It can be used as a top-level request field, which is convenient if one
wants to extract parameters from either the URL or HTTP template into the
request fields and also want access to the raw HTTP body.

Example:

    message GetResourceRequest {
      // A unique request id.
      string request_id = 1;

      // The raw HTTP body is bound to this field.
      google.api.HttpBody http_body = 2;
    }

    service ResourceService {
      rpc GetResource(GetResourceRequest) returns (google.api.HttpBody);
      rpc UpdateResource(google.api.HttpBody) returns
      (google.protobuf.Empty);
    }

Example with streaming methods:

    service CaldavService {
      rpc GetCalendar(stream google.api.HttpBody)
        returns (stream google.api.HttpBody);
      rpc UpdateCalendar(stream google.api.HttpBody)
        returns (stream google.api.HttpBody);
    }

Use of this type only changes how the request and response bodies are
handled, all other features will continue to work unchanged.
 */
export interface ApiHttpBody {
  /** The HTTP Content-Type header value specifying the content type of the body. */
  contentType?: string;
  /** The HTTP request/response body as raw binary. */
  data?: string;
  /** Application specific response metadata. Must be set in the first response
for streaming APIs. */
  extensions?: ProtobufAny[];
}

export type ApplicationActivities = typeof ApplicationActivities[keyof typeof ApplicationActivities];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApplicationActivities = {
  ACT_NONE: 'ACT_NONE',
  ACT_ADULT_ENTERTAINMENT: 'ACT_ADULT_ENTERTAINMENT',
  ACT_DRUGS: 'ACT_DRUGS',
  ACT_FIREARMS: 'ACT_FIREARMS',
  ACT_GAMBLING: 'ACT_GAMBLING',
  ACT_MARIJUANA: 'ACT_MARIJUANA',
  ACT_TUMBLING: 'ACT_TUMBLING',
} as const;

export type ApplicationBusiness = typeof ApplicationBusiness[keyof typeof ApplicationBusiness];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApplicationBusiness = {
  BSN_SOFTWARE: 'BSN_SOFTWARE',
  BSN_ATM: 'BSN_ATM',
  BSN_BROKER: 'BSN_BROKER',
  BSN_CHARITY: 'BSN_CHARITY',
  BSN_COMMODITIES: 'BSN_COMMODITIES',
  BSN_DEFI_EXCHANGE: 'BSN_DEFI_EXCHANGE',
  BSN_GOVERNMENT_FOREIGN: 'BSN_GOVERNMENT_FOREIGN',
  BSN_GOVERNMENT_US: 'BSN_GOVERNMENT_US',
  BSN_HNWI: 'BSN_HNWI',
  BSN_INSURANCE: 'BSN_INSURANCE',
  BSN_ADVISOR: 'BSN_ADVISOR',
  BSN_LOAN: 'BSN_LOAN',
  BSN_MINER: 'BSN_MINER',
  BSN_NFT: 'BSN_NFT',
  BSN_NON_BANK_CUSTODIAN: 'BSN_NON_BANK_CUSTODIAN',
  BSN_PENSION: 'BSN_PENSION',
  BSN_WHV: 'BSN_WHV',
  BSN_POOLED_INVESTMENT: 'BSN_POOLED_INVESTMENT',
  BSN_PROP_TRADING: 'BSN_PROP_TRADING',
  BSN_PUBLIC: 'BSN_PUBLIC',
  BSN_SPV: 'BSN_SPV',
  BSN_STATE_FOREIGN: 'BSN_STATE_FOREIGN',
  BSN_STATE_US: 'BSN_STATE_US',
  BSN_SUPRANATIONAL_BODY: 'BSN_SUPRANATIONAL_BODY',
  BSN_PAYMENT_PROCESSOR: 'BSN_PAYMENT_PROCESSOR',
  BSN_TOKEN_PROJECT: 'BSN_TOKEN_PROJECT',
  BSN_TRUST_PERSONAL: 'BSN_TRUST_PERSONAL',
  BSN_TRUST_CORP: 'BSN_TRUST_CORP',
  BSN_BANK_US: 'BSN_BANK_US',
  BSN_BANK_FOREIGN: 'BSN_BANK_FOREIGN',
  BSN_CRYPTO_MSB_US: 'BSN_CRYPTO_MSB_US',
  BSN_CRYPTO_MSB_FOREIGN: 'BSN_CRYPTO_MSB_FOREIGN',
  BSN_NON_CRYPTO_MSB_US: 'BSN_NON_CRYPTO_MSB_US',
  BSN_NON_CRYPTO_MSB_FOREIGN: 'BSN_NON_CRYPTO_MSB_FOREIGN',
  BSN_OTHER: 'BSN_OTHER',
} as const;

export type ApplicationControlExemption = typeof ApplicationControlExemption[keyof typeof ApplicationControlExemption];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApplicationControlExemption = {
  CRL_REGULATED: 'CRL_REGULATED',
  CRL_PUBLICLY_TRADED: 'CRL_PUBLICLY_TRADED',
  CRL_PUBLIC_SUBSIDIARY: 'CRL_PUBLIC_SUBSIDIARY',
  CRL_PUBLIC_ACCOUNTING: 'CRL_PUBLIC_ACCOUNTING',
  CRL_INSURANCE: 'CRL_INSURANCE',
  CRL_GOVERNMENT_AGENCY: 'CRL_GOVERNMENT_AGENCY',
  CRL_BANK_HOLDING: 'CRL_BANK_HOLDING',
  CRL_SAVINGS_LOAN: 'CRL_SAVINGS_LOAN',
  CRL_FMU: 'CRL_FMU',
  CRL_FOREIGN_PRIVATE_BANK: 'CRL_FOREIGN_PRIVATE_BANK',
  CRL_FOREIGN_INSTITUTION: 'CRL_FOREIGN_INSTITUTION',
  CRL_ISSUER: 'CRL_ISSUER',
  CRL_INVESTMENT: 'CRL_INVESTMENT',
  CRL_COMMODITIES: 'CRL_COMMODITIES',
  CRL_POOLED_INVESTMENT: 'CRL_POOLED_INVESTMENT',
  CRL_NON_GOVERNMENT_SUBDIVISION: 'CRL_NON_GOVERNMENT_SUBDIVISION',
  CRL_NON_ENTITY: 'CRL_NON_ENTITY',
  CRL_NONE: 'CRL_NONE',
} as const;

export interface ApplicationCorporateInvestment {
  primarySourceOfFunds?: ApplicationSourceFunds;
  totalInvestableAssets?: ApplicationValueLimits;
  totalAssets?: ApplicationValueLimits;
  assetAllocationToCrypto?: ApplicationValueLimits;
  investmentExperienceCrypto?: ApplicationInvestmentExperience;
  investmentStrategyCrypto?: ApplicationInvestmentStrategy;
  initialDepositSource?: ApplicationDeposits;
  initialDepositSourceCryptoDetails?: string;
  initialDepositSourceFiatDetails?: string;
  ongoingDepositSource?: ApplicationDeposits;
  frequencyOfCryptoTransactions?: ApplicationFrequency;
  cryptoInvestmentPlans?: ApplicationInvestmentPlan;
  investmentProceedsUse?: string;
  expectedCryptoAssets?: string;
  performTransfersWithUnhostedWallets?: boolean;
  knownUnhostedWalletAddresses?: string;
  tradesPerMonth?: ApplicationTradeLimits;
  usdValueOfCrypto?: ApplicationValueLimits;
  frequencyOfTransactions?: ApplicationFrequency;
  monthlyCryptoInvestmentDeposit?: ApplicationInvestmentValueLimits;
  monthlyInvestmentDeposit?: ApplicationInvestmentValueLimits;
  monthlyCryptoDeposits?: ApplicationCountLimits;
  monthlyDeposits?: ApplicationCountLimits;
  monthlyCryptoInvestmentWithdrawal?: ApplicationInvestmentValueLimits;
  monthlyInvestmentWithdrawal?: ApplicationInvestmentValueLimits;
  monthlyCryptoWithdrawals?: ApplicationCountLimits;
  monthlyWithdrawals?: ApplicationCountLimits;
  tradeInternationally?: boolean;
  tradeJurisdictions?: string[];
  primarySourceOfFundsDescription?: string;
  usdValueOfFiat?: ApplicationValueLimits;
}

export interface ApplicationCorporateKyc {
  primaryBusiness?: ApplicationBusiness;
  descriptionOfBusinessNature?: string;
  isCharitable?: boolean;
  businessJurisdictions?: string[];
  fundsSendReceiveJurisdictions?: string[];
  newYorkOffice?: boolean;
  engageInActivities?: ApplicationActivities[];
  regulatedStatus?: ApplicationRegulatedStatus;
  regulationAgency?: string;
  regulationAgencyRegulationNumber?: string;
  controlExemptionReason?: ApplicationControlExemption;
  numberOfOperation?: ApplicationCountLimits;
  aggregateUsdVolume1stMonth?: ApplicationValueLimits;
  aggregateUsdVolume3stMonth?: ApplicationValueLimits;
  aggregateUsdVolume6stMonth?: ApplicationValueLimits;
  regulatedNoLicenseExplain?: string;
  requireClientAccount?: boolean;
  vendorsAndCounterparties?: ApplicationVendors[];
}

export interface ApplicationCorporateReasons {
  bankStatementMissing?: string;
}

export type ApplicationCountLimits = typeof ApplicationCountLimits[keyof typeof ApplicationCountLimits];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApplicationCountLimits = {
  CLM_UPTO_5: 'CLM_UPTO_5',
  CLM_FIVE_TO_10: 'CLM_FIVE_TO_10',
  CLM_TEN_TO_25: 'CLM_TEN_TO_25',
  CLM_MORE_THAN_25: 'CLM_MORE_THAN_25',
} as const;

export type ApplicationDeposits = typeof ApplicationDeposits[keyof typeof ApplicationDeposits];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApplicationDeposits = {
  DEP_DEPOSIT: 'DEP_DEPOSIT',
  DEP_WIRE: 'DEP_WIRE',
} as const;

export type ApplicationDocumentStatus = typeof ApplicationDocumentStatus[keyof typeof ApplicationDocumentStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApplicationDocumentStatus = {
  DST_APPROVED: 'DST_APPROVED',
  DST_CHANGES_REQUESTED: 'DST_CHANGES_REQUESTED',
  DST_MISSING: 'DST_MISSING',
  DST_REJECTED: 'DST_REJECTED',
  DST_SUBMITTED: 'DST_SUBMITTED',
} as const;

export type ApplicationDocumentType = typeof ApplicationDocumentType[keyof typeof ApplicationDocumentType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApplicationDocumentType = {
  UNSET: 'UNSET',
  INCORPORATION_DOCUMENTS: 'INCORPORATION_DOCUMENTS',
  BENEFICIAL_CERTIFICATE: 'BENEFICIAL_CERTIFICATE',
  DIRECTORSHIP_CONFIRMATION: 'DIRECTORSHIP_CONFIRMATION',
  DRIVERS_LICENCE_FRONT: 'DRIVERS_LICENCE_FRONT',
  DRIVERS_LICENCE_BACK: 'DRIVERS_LICENCE_BACK',
  PASSPORT: 'PASSPORT',
  GOVERNMENT_ID_FRONT: 'GOVERNMENT_ID_FRONT',
  GOVERNMENT_ID_BACK: 'GOVERNMENT_ID_BACK',
  UTILITY_BILL: 'UTILITY_BILL',
  FINANCIAL_STATEMENT: 'FINANCIAL_STATEMENT',
  LEASE_AGREEMENT: 'LEASE_AGREEMENT',
  SOCIAL_SECURITY_CARD: 'SOCIAL_SECURITY_CARD',
  POWER_OF_ATTORNEY: 'POWER_OF_ATTORNEY',
  ANNUAL_REPORT: 'ANNUAL_REPORT',
  PARTNERSHIP_AGREEMENT: 'PARTNERSHIP_AGREEMENT',
  LLC_AGREEMENT: 'LLC_AGREEMENT',
  ARTICLES_OF_INCORPORATION: 'ARTICLES_OF_INCORPORATION',
  LAYER2_ACCOUNT_AGREEMENT: 'LAYER2_ACCOUNT_AGREEMENT',
  ACCOUNT_AGREEMENT: 'ACCOUNT_AGREEMENT',
  IDENTITY_CARD_BACK: 'IDENTITY_CARD_BACK',
  IDENTITY_CARD_FRONT: 'IDENTITY_CARD_FRONT',
  PAYSLIP: 'PAYSLIP',
  BANK_STATEMENT: 'BANK_STATEMENT',
  OTHER_1: 'OTHER_1',
  OTHER_2: 'OTHER_2',
  OTHER_3: 'OTHER_3',
  OPERATION_DOCUMENT: 'OPERATION_DOCUMENT',
} as const;

export type ApplicationEmploymentStatus = typeof ApplicationEmploymentStatus[keyof typeof ApplicationEmploymentStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApplicationEmploymentStatus = {
  EMP_EMPLOYEE: 'EMP_EMPLOYEE',
  EMP_SELF_EMPLOYED: 'EMP_SELF_EMPLOYED',
  EMP_RETIRED: 'EMP_RETIRED',
  EMP_UNEMPLOYED: 'EMP_UNEMPLOYED',
  EMP_OTHER: 'EMP_OTHER',
} as const;

export type ApplicationEntityType = typeof ApplicationEntityType[keyof typeof ApplicationEntityType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApplicationEntityType = {
  ETT_C_CORP_PRIVATE: 'ETT_C_CORP_PRIVATE',
  ETT_C_CORP_PUBLIC: 'ETT_C_CORP_PUBLIC',
  ETT_HNWI: 'ETT_HNWI',
  ETT_LLC: 'ETT_LLC',
  ETT_LLP: 'ETT_LLP',
  ETT_LP: 'ETT_LP',
  ETT_S_CORP: 'ETT_S_CORP',
  ETT_SOLE_PROP: 'ETT_SOLE_PROP',
  ETT_TRUST: 'ETT_TRUST',
  ETT_NON_PROFIT: 'ETT_NON_PROFIT',
  ETT_OTHER: 'ETT_OTHER',
} as const;

export type ApplicationFrequency = typeof ApplicationFrequency[keyof typeof ApplicationFrequency];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApplicationFrequency = {
  FRQ_DAILY: 'FRQ_DAILY',
  FRQ_WEEKLY: 'FRQ_WEEKLY',
  FRQ_BIWEEKLY: 'FRQ_BIWEEKLY',
  FRQ_MONTHLY: 'FRQ_MONTHLY',
  FRQ_QUARTERLY: 'FRQ_QUARTERLY',
  FRQ_SEMI_ANNUALLY: 'FRQ_SEMI_ANNUALLY',
} as const;

export interface ApplicationIndividualInvestment {
  primarySourceOfFunds?: ApplicationSourceFunds;
  primarySourceOfFundsDescription?: string;
  totalAssets?: ApplicationValueLimits;
  usdValueOfFiat?: ApplicationValueLimits;
  monthlyDeposits?: ApplicationCountLimits;
  monthlyWithdrawals?: ApplicationCountLimits;
  monthlyInvestmentDeposit?: ApplicationInvestmentValueLimits;
  monthlyInvestmentWithdrawal?: ApplicationInvestmentValueLimits;
  usdValueOfCrypto?: ApplicationValueLimits;
  monthlyCryptoDeposits?: ApplicationCountLimits;
  monthlyCryptoWithdrawals?: ApplicationCountLimits;
  monthlyCryptoInvestmentDeposit?: ApplicationInvestmentValueLimits;
  monthlyCryptoInvestmentWithdrawal?: ApplicationInvestmentValueLimits;
}

export interface ApplicationIndividualKyc {
  fundsSendReceiveJurisdictions?: string[];
  engageInActivities?: ApplicationActivities[];
  numberOfOperation?: ApplicationCountLimits;
  aggregateUsdVolume1stMonth?: ApplicationValueLimits;
  aggregateUsdVolume3stMonth?: ApplicationValueLimits;
  aggregateUsdVolume6stMonth?: ApplicationValueLimits;
  regulatedNoLicenseExplain?: string;
  requireClientAccount?: boolean;
  vendorsAndCounterparties?: ApplicationVendors[];
}

export type ApplicationIndividuals = typeof ApplicationIndividuals[keyof typeof ApplicationIndividuals];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApplicationIndividuals = {
  IND_INDIVIDUAL: 'IND_INDIVIDUAL',
  IND_OFFICER: 'IND_OFFICER',
  IND_BENEFICIAL_OWNER: 'IND_BENEFICIAL_OWNER',
  IND_CONTROL_PERSON: 'IND_CONTROL_PERSON',
  IND_AUTHORIZED_PERSON: 'IND_AUTHORIZED_PERSON',
} as const;

export type ApplicationInvestmentExperience = typeof ApplicationInvestmentExperience[keyof typeof ApplicationInvestmentExperience];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApplicationInvestmentExperience = {
  INE_LITTLE: 'INE_LITTLE',
  INE_MODERATE: 'INE_MODERATE',
  INE_SIGNIFICANT: 'INE_SIGNIFICANT',
} as const;

export type ApplicationInvestmentPlan = typeof ApplicationInvestmentPlan[keyof typeof ApplicationInvestmentPlan];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApplicationInvestmentPlan = {
  INP_CUSTODY: 'INP_CUSTODY',
  INP_STAKING: 'INP_STAKING',
  INP_TRADING: 'INP_TRADING',
  INP_LENDING: 'INP_LENDING',
  INP_BORROWING: 'INP_BORROWING',
} as const;

export type ApplicationInvestmentStrategy = typeof ApplicationInvestmentStrategy[keyof typeof ApplicationInvestmentStrategy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApplicationInvestmentStrategy = {
  INS_LOW_RISK: 'INS_LOW_RISK',
  INS_MEDIUM_RISK: 'INS_MEDIUM_RISK',
  INS_HIGH_RISK: 'INS_HIGH_RISK',
  INS_OTHER: 'INS_OTHER',
} as const;

export type ApplicationInvestmentValueLimits = typeof ApplicationInvestmentValueLimits[keyof typeof ApplicationInvestmentValueLimits];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApplicationInvestmentValueLimits = {
  ILM_UPTO_1K: 'ILM_UPTO_1K',
  ILM_ONE_TO_100K: 'ILM_ONE_TO_100K',
  ILM_ONEHUNDREDK_TO_1M: 'ILM_ONEHUNDREDK_TO_1M',
  ILM_MILLION_TO_5M: 'ILM_MILLION_TO_5M',
  ILM_MORE_THAN_5M: 'ILM_MORE_THAN_5M',
} as const;

export type ApplicationRegulatedStatus = typeof ApplicationRegulatedStatus[keyof typeof ApplicationRegulatedStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApplicationRegulatedStatus = {
  RGS_REGULATED: 'RGS_REGULATED',
  RGS_REGISTERED: 'RGS_REGISTERED',
  RGS_LICENSED: 'RGS_LICENSED',
  RGS_NONE: 'RGS_NONE',
  RGS_NOT_REQUIRED: 'RGS_NOT_REQUIRED',
} as const;

export type ApplicationSourceFunds = typeof ApplicationSourceFunds[keyof typeof ApplicationSourceFunds];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApplicationSourceFunds = {
  SFD_EMPLOYMENT: 'SFD_EMPLOYMENT',
  SFD_SAVINGS: 'SFD_SAVINGS',
  SFD_WINNINGS: 'SFD_WINNINGS',
  SFD_MARITAL: 'SFD_MARITAL',
  SFD_REAL_ESTATE: 'SFD_REAL_ESTATE',
  SFD_TRUST: 'SFD_TRUST',
  SFD_INVESTMENT: 'SFD_INVESTMENT',
  SFD_COMPANY: 'SFD_COMPANY',
  SFD_COMPANY_CAPITAL: 'SFD_COMPANY_CAPITAL',
  SFD_LOAN: 'SFD_LOAN',
  SFD_PRIVATE_CAPITAL: 'SFD_PRIVATE_CAPITAL',
  SFD_GRANT: 'SFD_GRANT',
  SFD_OTHER: 'SFD_OTHER',
} as const;

export type ApplicationTradeLimits = typeof ApplicationTradeLimits[keyof typeof ApplicationTradeLimits];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApplicationTradeLimits = {
  TRL_UPTO_20: 'TRL_UPTO_20',
  TRL_TWENTYONE_TO_30: 'TRL_TWENTYONE_TO_30',
  TRL_THIRTYONE_TO_100: 'TRL_THIRTYONE_TO_100',
  TRL_ONEHUNDREDANDONE_TO_200: 'TRL_ONEHUNDREDANDONE_TO_200',
  TRL_TWOHUNDREDANDONE_TO_400: 'TRL_TWOHUNDREDANDONE_TO_400',
  TRL_MORE_THAN_400: 'TRL_MORE_THAN_400',
} as const;

export type ApplicationUsResident = typeof ApplicationUsResident[keyof typeof ApplicationUsResident];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApplicationUsResident = {
  RES_US_CITIZEN: 'RES_US_CITIZEN',
  RES_RESIDENT_ALIEN: 'RES_RESIDENT_ALIEN',
  RES_NON_RESIDENT_ALIEN: 'RES_NON_RESIDENT_ALIEN',
} as const;

export type ApplicationValueLimits = typeof ApplicationValueLimits[keyof typeof ApplicationValueLimits];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApplicationValueLimits = {
  VLM_UPTO_10K: 'VLM_UPTO_10K',
  VLM_TEN_TO_100K: 'VLM_TEN_TO_100K',
  VLM_ONEHUNDREDK_TO_1M: 'VLM_ONEHUNDREDK_TO_1M',
  VLM_ONE_TO_10M: 'VLM_ONE_TO_10M',
  VLM_TEN_TO_50M: 'VLM_TEN_TO_50M',
  VLM_FIFTY_TO_250M: 'VLM_FIFTY_TO_250M',
  VLM_MORE_THAN_250M: 'VLM_MORE_THAN_250M',
} as const;

export type ApplicationVendors = typeof ApplicationVendors[keyof typeof ApplicationVendors];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApplicationVendors = {
  VND_SELF: 'VND_SELF',
  VND_MERCHANTS_SUPPLIERS: 'VND_MERCHANTS_SUPPLIERS',
  VND_CUSTOMERS: 'VND_CUSTOMERS',
  VND_EMPLOYEES: 'VND_EMPLOYEES',
  VND_CONTRACTORS: 'VND_CONTRACTORS',
  VND_FRIENDS: 'VND_FRIENDS',
  VND_FAMILY: 'VND_FAMILY',
} as const;

export interface AuthConfirmRecoveryRequest {
  code: string;
  token: string;
  password: string;
  repeatPassword: string;
}

export interface AuthLoginModel {
  login: string;
  password: string;
  code?: string;
}

export interface AuthOtpEnableRequest { [key: string]: unknown }

export interface AuthOtpQrRespond {
  qr?: string;
  secret?: string;
}

export interface AuthOtpRespond {
  success?: boolean;
}

export interface AuthPartnerRespond {
  item?: V2authPartner;
}

export interface AuthProfilePartner {
  id?: string;
  name?: string;
  email?: string;
  phone?: string;
}

export interface AuthProfileRespond {
  item?: V2authProfile;
}

export interface AuthProfileUser {
  id?: string;
  name?: string;
  email?: string;
  phone?: string;
  is2FA?: boolean;
}

export interface AuthRecoveryRequest {
  login: string;
}

export interface AuthRecoveryRespond {
  token?: string;
}

export interface BillingAmount {
  units?: string;
  nanos?: number;
}

export interface BillingCommissionAccountListRespond {
  items?: V2billingCommissionAccount[];
  meta?: V2ListMeta;
}

export interface BillingCreateOperationRequest {
  customerId: string;
  paymentType?: Billingv1PaymentType;
  type: Billingv1OperationType;
  sourceRequisit?: V2billingRequisit;
  destinationRequisit?: V2billingRequisit;
  amount: BillingAmount;
  comment?: string;
  reference?: string;
  documents?: BillingOperationDocumentUpload[];
}

export interface BillingCurrencyCommissionCommission {
  partner?: Billingv1Commission;
  default?: Billingv1Commission;
}

export interface BillingCurrencyCommissionListRespond {
  items?: V2billingCurrencyCommission[];
}

export type BillingGetCommissionRequestPaymentType = typeof BillingGetCommissionRequestPaymentType[keyof typeof BillingGetCommissionRequestPaymentType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BillingGetCommissionRequestPaymentType = {
  PAYMENT_TYPE_NOT_SET: 'PAYMENT_TYPE_NOT_SET',
  EMPTY: 'EMPTY',
  ACH: 'ACH',
  FEDWIRE: 'FEDWIRE',
  SWIFT: 'SWIFT',
  CRYPTO: 'CRYPTO',
  EFT: 'EFT',
  SEPA_CT: 'SEPA_CT',
  IMPS: 'IMPS',
} as const;

export interface BillingLimitsListRespond {
  items?: V2billingLimit[];
  meta?: V2ListMeta;
}

export type BillingListLimitsRequestPaymentType = typeof BillingListLimitsRequestPaymentType[keyof typeof BillingListLimitsRequestPaymentType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BillingListLimitsRequestPaymentType = {
  PAYMENT_TYPE_NOT_SET: 'PAYMENT_TYPE_NOT_SET',
  EMPTY: 'EMPTY',
  ACH: 'ACH',
  FEDWIRE: 'FEDWIRE',
  SWIFT: 'SWIFT',
  CRYPTO: 'CRYPTO',
  EFT: 'EFT',
  SEPA_CT: 'SEPA_CT',
  IMPS: 'IMPS',
} as const;

export type BillingListOperationRequestOperationType = typeof BillingListOperationRequestOperationType[keyof typeof BillingListOperationRequestOperationType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BillingListOperationRequestOperationType = {
  NOTSET: 'NOTSET',
  DEPOSIT: 'DEPOSIT',
  TRANSFER: 'TRANSFER',
  WITHDRAW: 'WITHDRAW',
  COMMISSION: 'COMMISSION',
  EXCHANGE: 'EXCHANGE',
} as const;

export type BillingListOperationRequestStatus = typeof BillingListOperationRequestStatus[keyof typeof BillingListOperationRequestStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BillingListOperationRequestStatus = {
  NOT_SET: 'NOT_SET',
  NEW: 'NEW',
  PENDING: 'PENDING',
  WORKING: 'WORKING',
  SUCCESS: 'SUCCESS',
  FAIL: 'FAIL',
  CANCELED: 'CANCELED',
} as const;

export interface BillingListOperationRespond {
  meta?: V2ListMeta;
  items?: BillingOperationModelList[];
}

export interface BillingOperationDocumentUpload {
  id?: string;
  name?: string;
}

export interface BillingOperationModel {
  operationId?: string;
  isVisible?: boolean;
  status?: V1OperationStatus;
  type?: Billingv1OperationType;
  paymentType?: Billingv1PaymentType;
  createdAt?: string;
  updatedAt?: string;
  source?: Billingv1Requisit;
  destination?: Billingv1Requisit;
  sourceAmount?: V1Ammount;
  destinationAmount?: V1Ammount;
  commissionAmount?: V1Ammount;
  currentBalanceAmount?: V1Ammount;
  comment?: string;
  reference?: string;
  isParent?: boolean;
  customer?: BillingOperationModelCustomer;
  documents?: Gatewayv2Document[];
}

export interface BillingOperationModelCustomer {
  id?: string;
  name?: string;
}

export interface BillingOperationModelDetail {
  operationId?: string;
  isVisible?: boolean;
  status?: V1OperationStatus;
  type?: Billingv1OperationType;
  paymentType?: Billingv1PaymentType;
  createdAt?: string;
  updatedAt?: string;
  source?: BillingOperationModelDetailRequisit;
  destination?: BillingOperationModelDetailRequisit;
  sourceAmount?: V1Ammount;
  destinationAmount?: V1Ammount;
  commissionAmount?: V1Ammount;
  currentBalanceAmount?: V1Ammount;
  comment?: string;
  isParent?: boolean;
  reference?: string;
  customer?: BillingOperationModelDetailCustomer;
  documents?: Gatewayv2Document[];
}

export interface BillingOperationModelDetailAccount {
  id?: string;
  name?: string;
  number?: string;
  customer?: BillingOperationModelDetailCustomer;
}

export interface BillingOperationModelDetailCounterparty {
  id?: string;
  name?: string;
  bankName?: string;
  bankAddress?: Delosbeneficiaryv1Address;
}

export interface BillingOperationModelDetailCounterpartyAccount {
  id?: string;
  name?: string;
  number?: string;
  counterparty?: BillingOperationModelDetailCounterparty;
  customer?: BillingOperationModelDetailCustomer;
}

export interface BillingOperationModelDetailCustomer {
  id?: string;
  name?: string;
}

export interface BillingOperationModelDetailRequisit {
  account?: BillingOperationModelDetailAccount;
  counterpartyAccount?: BillingOperationModelDetailCounterpartyAccount;
}

export interface BillingOperationModelList {
  operationId?: string;
  isVisible?: boolean;
  status?: V1OperationStatus;
  type?: Billingv1OperationType;
  paymentType?: Billingv1PaymentType;
  createdAt?: string;
  updatedAt?: string;
  source?: BillingOperationModelListRequisit;
  destination?: BillingOperationModelListRequisit;
  sourceAmount?: V1Ammount;
  destinationAmount?: V1Ammount;
  commissionAmount?: V1Ammount;
  comment?: string;
  reference?: string;
  isParent?: boolean;
  customer?: BillingOperationModelListCustomer;
  documents?: Gatewayv2Document[];
}

export interface BillingOperationModelListAccount {
  id?: string;
  name?: string;
  number?: string;
  customer?: BillingOperationModelListCustomer;
}

export interface BillingOperationModelListCounterparty {
  id?: string;
  name?: string;
  bankName?: string;
  bankAddress?: Delosbeneficiaryv1Address;
}

export interface BillingOperationModelListCounterpartyAccount {
  id?: string;
  name?: string;
  number?: string;
  counterparty?: BillingOperationModelListCounterparty;
  customer?: BillingOperationModelListCustomer;
}

export interface BillingOperationModelListCustomer {
  id?: string;
  name?: string;
  type?: UsersClientType;
}

export interface BillingOperationModelListRequisit {
  account?: BillingOperationModelListAccount;
  counterpartyAccount?: BillingOperationModelListCounterpartyAccount;
}

export interface BillingOperationRespond {
  item?: BillingOperationModelDetail;
}

export interface BillingOperationTreeRespond {
  general?: BillingOperationModel;
  childs?: BillingOperationModel[];
}

export interface BillingSetCommissionRespond {
  item?: V2billingCurrencyCommission;
}

export interface BillingSetLimitRequest {
  id?: number;
  customerId?: string;
  currencyCodeFrom?: string;
  currencyCodeTo?: string;
  operationType?: Billingv1OperationType;
  paymentType?: BillingSetLimitRequestPaymentType;
  min?: number;
  max?: number;
}

export type BillingSetLimitRequestPaymentType = typeof BillingSetLimitRequestPaymentType[keyof typeof BillingSetLimitRequestPaymentType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BillingSetLimitRequestPaymentType = {
  NOT_SET: 'NOT_SET',
  EMPTY: 'EMPTY',
  ACH: 'ACH',
  FEDWIRE: 'FEDWIRE',
  SWIFT: 'SWIFT',
  CRYPTO: 'CRYPTO',
  EFT: 'EFT',
  SEPA_CT: 'SEPA_CT',
  IMPS: 'IMPS',
} as const;

export interface BillingSetLimitRespond {
  item?: V2billingLimit;
}

export interface Billingv1Commission {
  percent?: number;
  fixed?: number;
}

export type Billingv1OperationType = typeof Billingv1OperationType[keyof typeof Billingv1OperationType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Billingv1OperationType = {
  NOTSET: 'NOTSET',
  DEPOSIT: 'DEPOSIT',
  TRANSFER: 'TRANSFER',
  WITHDRAW: 'WITHDRAW',
  COMMISSION: 'COMMISSION',
  EXCHANGE: 'EXCHANGE',
  CORRECTING: 'CORRECTING',
} as const;

export type Billingv1PaymentType = typeof Billingv1PaymentType[keyof typeof Billingv1PaymentType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Billingv1PaymentType = {
  EMPTY: 'EMPTY',
  ACH: 'ACH',
  FEDWIRE: 'FEDWIRE',
  SWIFT: 'SWIFT',
  CRYPTO: 'CRYPTO',
  EFT: 'EFT',
  SEPA_CT: 'SEPA_CT',
  IMPS: 'IMPS',
} as const;

export interface Billingv1Requisit {
  account?: string;
  beneficiar?: string;
  accountProvider?: IntegrationFinanceProvider;
  beneficiarProvider?: IntegrationFinanceProvider;
  cuid?: string;
}

export interface CommonsearchFilter {
  attribute?: string;
  operator?: FilterOperator;
  condition?: FilterCondition;
  values?: string[];
  groupConditions?: CommonsearchFilter[];
}

export type CounterpartyCPAccountType = typeof CounterpartyCPAccountType[keyof typeof CounterpartyCPAccountType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CounterpartyCPAccountType = {
  CHECKING: 'CHECKING',
  SAVING: 'SAVING',
} as const;

export type CounterpartyCPLineOfBusiness = typeof CounterpartyCPLineOfBusiness[keyof typeof CounterpartyCPLineOfBusiness];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CounterpartyCPLineOfBusiness = {
  PLB_ARTS_AND_ANTIQUES: 'PLB_ARTS_AND_ANTIQUES',
  PLB_AGRICULTURE: 'PLB_AGRICULTURE',
  PLB_AUDIT_VIDEO: 'PLB_AUDIT_VIDEO',
  PLB_AUTOMOTIVE: 'PLB_AUTOMOTIVE',
  PLB_BANK_CREDIT_UNION: 'PLB_BANK_CREDIT_UNION',
  PLB_BIOTECH_PHARMACEUTICAL: 'PLB_BIOTECH_PHARMACEUTICAL',
  PLB_BOOKSELLER: 'PLB_BOOKSELLER',
  PLB_CONSTRUCTION: 'PLB_CONSTRUCTION',
  PLB_CASINOS_GAMBLING: 'PLB_CASINOS_GAMBLING',
  PLB_CLOTHING: 'PLB_CLOTHING',
  PLB_CONSULTING_PROFESSIONAL_SERVICES: 'PLB_CONSULTING_PROFESSIONAL_SERVICES',
  PLB_CRYPTOCURRENCY: 'PLB_CRYPTOCURRENCY',
  PLB_ECIGARETTES_TOBACCO: 'PLB_ECIGARETTES_TOBACCO',
  PLB_ENERGY_CHEMICAL_FUEL: 'PLB_ENERGY_CHEMICAL_FUEL',
  PLB_ENGINEERING: 'PLB_ENGINEERING',
  PLB_ADULT_ENTERTAINMENT: 'PLB_ADULT_ENTERTAINMENT',
  PLB_FINANCIAL_AND_CORPORATE_SERVICES: 'PLB_FINANCIAL_AND_CORPORATE_SERVICES',
  PLB_FOOD_AND_BEVERAGE: 'PLB_FOOD_AND_BEVERAGE',
  PLB_FREIGHT_MARINE_SHIPPING_SERVICES: 'PLB_FREIGHT_MARINE_SHIPPING_SERVICES',
  PLB_GIFTWARE_SEASONAL: 'PLB_GIFTWARE_SEASONAL',
  PLB_GOVERNMENT_PUBLIC_SERVICES: 'PLB_GOVERNMENT_PUBLIC_SERVICES',
  PLB_HIGH_TECH_SOFTWARE_TELECOMS: 'PLB_HIGH_TECH_SOFTWARE_TELECOMS',
  PLB_HOSPITALITY: 'PLB_HOSPITALITY',
  PLB_HOUSEHOLD_GOOD_FURNITURE: 'PLB_HOUSEHOLD_GOOD_FURNITURE',
  PLB_HUMAN_RESOURCE_SERVICES: 'PLB_HUMAN_RESOURCE_SERVICES',
  PLB_INDUSTRIAL_EQUIPMENT: 'PLB_INDUSTRIAL_EQUIPMENT',
  PLB_INFORMATION_TECHNOLOGY: 'PLB_INFORMATION_TECHNOLOGY',
  PLB_INSURANCE: 'PLB_INSURANCE',
  PLB_JEWELLERY_OPTICAL: 'PLB_JEWELLERY_OPTICAL',
  PLB_LAW: 'PLB_LAW',
  PLB_MANUFACTURING: 'PLB_MANUFACTURING',
  PLB_MARKETING: 'PLB_MARKETING',
  PLB_MEDIA_PUBLISHING: 'PLB_MEDIA_PUBLISHING',
  PLB_MEDICAL_HEALTHCARE: 'PLB_MEDICAL_HEALTHCARE',
  PLB_MEDICAL_TOURISM: 'PLB_MEDICAL_TOURISM',
  PLB_MINING: 'PLB_MINING',
  PLB_MONEY_SERVICE_BUSINESS: 'PLB_MONEY_SERVICE_BUSINESS',
  PLB_NON_PROFIT_CHARITY: 'PLB_NON_PROFIT_CHARITY',
  PLB_ONLINE_RETAIL: 'PLB_ONLINE_RETAIL',
  PLB_PAYROLL: 'PLB_PAYROLL',
  PLB_PENSION: 'PLB_PENSION',
  PLB_PERSONAL_CARE_PRODUCTS: 'PLB_PERSONAL_CARE_PRODUCTS',
  PLB_PHOTOGRAPHY: 'PLB_PHOTOGRAPHY',
  PLB_REAL_ESTATE: 'PLB_REAL_ESTATE',
  PLB_RECREATIONAL_ACTIVITIES: 'PLB_RECREATIONAL_ACTIVITIES',
  PLB_RELIGIOUS_ORGANISATION: 'PLB_RELIGIOUS_ORGANISATION',
  PLB_RETAIL: 'PLB_RETAIL',
  PLB_SECURITY: 'PLB_SECURITY',
  PLB_SPORTING_RECREATIONAL_PRODUCTS: 'PLB_SPORTING_RECREATIONAL_PRODUCTS',
  PLB_TRANSPORT: 'PLB_TRANSPORT',
  PLB_UNIVERSITY_EDUCATION: 'PLB_UNIVERSITY_EDUCATION',
  PLB_UTILITIES: 'PLB_UTILITIES',
  PLB_WASTE_MANAGEMENT: 'PLB_WASTE_MANAGEMENT',
  PLB_WINE_LIQUOR: 'PLB_WINE_LIQUOR',
  PLB_TECHNICAL_SUPPORT: 'PLB_TECHNICAL_SUPPORT',
  PLB_OTHER: 'PLB_OTHER',
} as const;

export type CounterpartyCPProfileType = typeof CounterpartyCPProfileType[keyof typeof CounterpartyCPProfileType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CounterpartyCPProfileType = {
  INDIVIDUAL: 'INDIVIDUAL',
  CORPORATION: 'CORPORATION',
} as const;

export type CounterpartyCPRails = typeof CounterpartyCPRails[keyof typeof CounterpartyCPRails];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CounterpartyCPRails = {
  ACH: 'ACH',
  CRYPTO: 'CRYPTO',
  IMPS: 'IMPS',
  NFT: 'NFT',
  UP: 'UP',
  SWIFT: 'SWIFT',
  FPS: 'FPS',
  SEPA_CT: 'SEPA_CT',
  EFT: 'EFT',
  FEDWIRE: 'FEDWIRE',
} as const;

export type CounterpartyCPRelationshipToCustomer = typeof CounterpartyCPRelationshipToCustomer[keyof typeof CounterpartyCPRelationshipToCustomer];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CounterpartyCPRelationshipToCustomer = {
  PRC_SPOUSE: 'PRC_SPOUSE',
  PRC_EX_SPOUSE: 'PRC_EX_SPOUSE',
  PRC_CHILDREN: 'PRC_CHILDREN',
  PRC_PARENT: 'PRC_PARENT',
  PRC_SIBLING: 'PRC_SIBLING',
  PRC_RELATIVE: 'PRC_RELATIVE',
  PRC_SELF: 'PRC_SELF',
  PRC_FRIEND: 'PRC_FRIEND',
  PRC_BUSINESS_PARTNER: 'PRC_BUSINESS_PARTNER',
  PRC_CUSTOMER: 'PRC_CUSTOMER',
  PRC_EMPLOYEE: 'PRC_EMPLOYEE',
  PRC_BRANCH_OFFICE: 'PRC_BRANCH_OFFICE',
  PRC_SUBSIDIARY_COMPANY: 'PRC_SUBSIDIARY_COMPANY',
  PRC_HOLDING_COMPANY: 'PRC_HOLDING_COMPANY',
  PRC_SUPPLIER: 'PRC_SUPPLIER',
  PRC_CREDITOR: 'PRC_CREDITOR',
  PRC_DEBTOR: 'PRC_DEBTOR',
  PRC_FRANCHISEE: 'PRC_FRANCHISEE',
  PRC_NOT_RELATED: 'PRC_NOT_RELATED',
} as const;

export type CounterpartyCPType = typeof CounterpartyCPType[keyof typeof CounterpartyCPType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CounterpartyCPType = {
  TYPE_CRYPTO: 'TYPE_CRYPTO',
  TYPE_FIAT_IN: 'TYPE_FIAT_IN',
  TYPE_FIAT_GB: 'TYPE_FIAT_GB',
  TYPE_FIAT_EU: 'TYPE_FIAT_EU',
  TYPE_FIAT_BS: 'TYPE_FIAT_BS',
  TYPE_FIAT_CA: 'TYPE_FIAT_CA',
  TYPE_FIAT_PA: 'TYPE_FIAT_PA',
  TYPE_FIAT_MY: 'TYPE_FIAT_MY',
  TYPE_FIAT_JP: 'TYPE_FIAT_JP',
  TYPE_FIAT_SG: 'TYPE_FIAT_SG',
  TYPE_FIAT_HK: 'TYPE_FIAT_HK',
  TYPE_FIAT_CN: 'TYPE_FIAT_CN',
  TYPE_FIAT_US: 'TYPE_FIAT_US',
} as const;

export type CounterpartyCPWalletType = typeof CounterpartyCPWalletType[keyof typeof CounterpartyCPWalletType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CounterpartyCPWalletType = {
  CPW_INSTITUTION: 'CPW_INSTITUTION',
  CPW_OTHER: 'CPW_OTHER',
  CPW_UNKNOWN: 'CPW_UNKNOWN',
} as const;

export interface CounterpartyCounterpartiesCreateAccountBody {
  item?: V2counterpartyCounterpartyAccount;
}

export interface CounterpartyCounterpartiesUpdateAccountBody {
  item?: V2counterpartyCounterpartyAccount;
}

export interface CounterpartyCounterpartiesUpdateBody {
  readonly customerId?: string;
  description?: string;
  profile?: CounterpartyUpdateCounterpartyRequestProfile;
  accounts?: CounterpartyUpdateCounterpartyRequestAccount[];
}

export interface CounterpartyCounterpartyAccountFullV2 {
  readonly accountId?: string;
  currencyCode?: string;
  status?: Delosbeneficiaryv1AccountStatus;
  bank?: Delosbeneficiaryv1BankInfo;
  name?: string;
  number?: string;
  type?: string;
  crypto?: V1AccountCrypto;
  fiat?: V1AccountFiat;
  counterparty?: CounterpartyCounterpartyV2;
  customer?: CounterpartyCustomerV2;
  createdAt?: string;
  updatedAt?: string;
}

export interface CounterpartyCounterpartyAccountResponseV2 {
  item?: CounterpartyCounterpartyAccountFullV2;
}

export interface CounterpartyCounterpartyAccountV2 {
  accountId?: string;
  name?: string;
  number?: string;
  currencyCode?: string;
  type?: string;
  counterparty?: CounterpartyCounterpartyV2;
  customer?: CounterpartyCustomerV2;
  createdAt?: string;
  updatedAt?: string;
  status?: Delosbeneficiaryv1AccountStatus;
  bankName?: string;
  bankAddress?: Delosbeneficiaryv1Address;
  supportedRails?: CounterpartyCPRails[];
}

export interface CounterpartyCounterpartyAccountsResponseV2 {
  meta?: V2ListMeta;
  items?: CounterpartyCounterpartyAccountV2[];
}

export interface CounterpartyCounterpartyDetail {
  readonly counterpartyId?: string;
  readonly customerId?: string;
  description?: string;
  profile?: V2counterpartyCounterpartyProfile;
  accounts?: V2counterpartyCounterpartyAccount[];
  createdAt?: string;
  updatedAt?: string;
  customerName?: string;
}

export interface CounterpartyCounterpartyDetailV2 {
  readonly counterpartyId?: string;
  description?: string;
  profile?: V2counterpartyCounterpartyProfile;
  createdAt?: string;
  updatedAt?: string;
  customer?: V2counterpartyCustomer;
}

export interface CounterpartyCounterpartyRespondV2 {
  item?: CounterpartyCounterpartyDetailV2;
  accounts?: CounterpartyCounterpartyRespondV2Account[];
}

export interface CounterpartyCounterpartyRespondV2Account {
  readonly accountId?: string;
  currencyCode?: string;
  status?: Delosbeneficiaryv1AccountStatus;
  bank?: Delosbeneficiaryv1BankInfo;
  name?: string;
  number?: string;
  type?: string;
  crypto?: V1AccountCrypto;
  fiat?: V1AccountFiat;
  createdAt?: string;
  updatedAt?: string;
}

export interface CounterpartyCounterpartyResponse {
  item?: CounterpartyCounterpartyDetail;
}

export interface CounterpartyCounterpartyV2 {
  id?: string;
  name?: string;
  phone?: string;
  email?: string;
}

export interface CounterpartyCreateCounterpartyRequest {
  customerId: string;
  description?: string;
  profile: CounterpartyCreateCounterpartyRequestProfile;
  accounts?: CounterpartyCreateCounterpartyRequestAccount[];
}

export interface CounterpartyCreateCounterpartyRequestAccount {
  currencyCode: string;
  bank?: Delosbeneficiaryv1BankInfo;
  crypto?: V1AccountCrypto;
  fiat?: V1AccountFiat;
}

export interface CounterpartyCreateCounterpartyRequestProfile {
  name: string;
  email?: string;
  phoneNumber?: string;
  taxNumber?: string;
  dateOfBirth?: string;
  address: Delosbeneficiaryv1Address;
  website?: string;
  additionalInfo?: CounterpartyProfileAdditionalInfo;
  lastname?: string;
}

export interface CounterpartyCustomerV2 {
  id?: string;
  name?: string;
  phone?: string;
  email?: string;
  status?: UsersClientStatus;
}

export interface CounterpartyListCounterpartiesRespond {
  meta?: V2ListMeta;
  items?: V2counterpartyCounterparty[];
}

export interface CounterpartyUpdateCounterpartyRequestAccount {
  accountId: string;
  currencyCode: string;
  bank?: Delosbeneficiaryv1BankInfo;
  crypto?: V1AccountCrypto;
  fiat?: V1AccountFiat;
}

export interface CounterpartyUpdateCounterpartyRequestProfile {
  name?: string;
  email?: string;
  phoneNumber?: string;
  taxNumber?: string;
  dateOfBirth?: string;
  address?: Delosbeneficiaryv1Address;
  website?: string;
  additionalInfo?: CounterpartyProfileAdditionalInfo;
  lastname?: string;
}

export interface CurrencyConvertRequest {
  amount: TypeMoney;
  currencyCodeTo: string;
}

export interface CurrencyConvertResponse {
  sourceAmount?: TypeMoney;
  convertedAmount?: TypeMoney;
}

export interface CurrencyCurrencyList {
  items?: CurrencyCurrencyModel[];
}

export interface CurrencyCurrencyModel {
  code?: string;
  name?: string;
  isCrypto?: boolean;
  isDefault?: boolean;
  rate?: number;
}

export interface CustomerCorporateApplication {
  application?: V2customerCorporateCustomer;
  individuals?: V2customerIndividualProfile[];
}

export interface CustomerCreateCustomerRequest {
  name: string;
  lastname?: string;
  comment?: string;
  company?: string;
  type?: UsersClientType;
}

export interface CustomerCustomerModel {
  customerId?: string;
  partnerId?: string;
  status?: UsersClientStatus;
  createAt?: string;
  updateAt?: string;
  name?: string;
  lastname?: string;
  comment?: string;
  company?: string;
  type?: UsersClientType;
  balance?: TypeMoney;
  balanceHold?: TypeMoney;
}

export interface CustomerCustomerModelDetail {
  customerId?: string;
  partnerId?: string;
  status?: UsersClientStatus;
  createAt?: string;
  updateAt?: string;
  name?: string;
  lastname?: string;
  comment?: string;
  company?: string;
  type?: UsersClientType;
  balance?: TypeMoney;
  balanceHold?: TypeMoney;
  phone?: string;
  email?: string;
}

export interface CustomerCustomerRespond {
  item?: CustomerCustomerModel;
}

export interface CustomerCustomerRespondDetail {
  item?: CustomerCustomerModelDetail;
}

export interface CustomerCustomerUpdateBody {
  name: string;
  lastname?: string;
  comment?: string;
  company?: string;
  status?: UsersClientStatus;
  type?: UsersClientType;
}

export interface CustomerDocumentRespond {
  document?: Gatewayv2Document;
}

export interface CustomerDocumentStreamRespond {
  document?: DelosstorageDocument;
  chunk?: string;
}

export interface CustomerDocumentUpload {
  /** Customer ID */
  customerId: string;
  /** Attached file for upload */
  attach: string;
  /** Optional short info about file. Optional */
  info?: string;
  type?: ApplicationDocumentType;
}

export interface CustomerGetApplicationRespond {
  individual?: CustomerIndividualApplication;
  corporate?: CustomerCorporateApplication;
}

export interface CustomerIndividualApplication {
  application?: V2customerIndividualCustomer;
}

export interface CustomerListCustomerRespond {
  meta?: V2ListMeta;
  items?: CustomerCustomerModel[];
}

export interface CustomerSetApplicationRespond {
  individual?: CustomerSetIndividualApplication;
  corporate?: CustomerSetCorporateApplication;
}

export interface CustomerSetCorporateApplication {
  application?: IntegrationapplicationCorporateCustomer;
  individuals?: IntegrationapplicationIndividualProfile[];
}

export interface CustomerSetIndividualApplication {
  application?: IntegrationapplicationIndividualCustomer;
}

export type Delosaccountsv1AccountStatus = typeof Delosaccountsv1AccountStatus[keyof typeof Delosaccountsv1AccountStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Delosaccountsv1AccountStatus = {
  NEW: 'NEW',
  PRE_MODERATION: 'PRE_MODERATION',
  MODERATION: 'MODERATION',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED',
  BANNED: 'BANNED',
  PROCESSING: 'PROCESSING',
} as const;

export interface DelosauthTokenRespond {
  accessToken?: string;
  refreshToken?: string;
  guid?: string;
}

export type Delosbeneficiaryv1AccountStatus = typeof Delosbeneficiaryv1AccountStatus[keyof typeof Delosbeneficiaryv1AccountStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Delosbeneficiaryv1AccountStatus = {
  NEW: 'NEW',
  AWAIT: 'AWAIT',
  MODERATION: 'MODERATION',
  ACCEPT: 'ACCEPT',
  REJECT: 'REJECT',
  BANNED: 'BANNED',
  VERIFICATION: 'VERIFICATION',
} as const;

export interface Delosbeneficiaryv1Address {
  addressLine1?: string;
  addressLine2?: string;
  addressLine3?: string;
  city?: string;
  stateIso?: string;
  countryIso?: string;
  postalCode?: string;
  unitNumber?: string;
}

export interface Delosbeneficiaryv1BankInfo {
  name?: string;
  number?: string;
  address?: Delosbeneficiaryv1Address;
  routingNumber?: string;
}

export interface DelosstorageDocument {
  guid?: string;
  cuid?: string;
  fileName?: string;
  size?: number;
  mime?: string;
  docType?: ApplicationDocumentType;
  info?: string;
  isLock?: boolean;
  createAt?: string;
  deletedAt?: string;
}

export interface DelosusersFile {
  id?: string;
  name?: string;
  type?: UsersFileType;
}

export interface Gatewayv2Document {
  id?: string;
  customerId?: string;
  fileName?: string;
  size?: number;
  mime?: string;
  docType?: ApplicationDocumentType;
  info?: string;
  isLock?: boolean;
  createAt?: string;
  status?: ApplicationDocumentStatus;
}

export interface Gatewayv2authOtpCodeRequest {
  code: string;
}

export interface Gatewayv2authTokenRespond {
  accessToken?: string;
  refreshToken?: string;
  userId?: string;
  accessTtl?: number;
  refreshTtl?: number;
}

export interface Gatewayv2authValidateRespond {
  userId?: string;
  valid?: boolean;
  expired?: number;
}

export interface GeoState {
  id?: number;
  iso?: string;
  code?: string;
  name?: string;
}

export interface GeoStates {
  items?: GeoState[];
  meta?: V2ListMeta;
}

export interface GooglerpcStatus {
  code?: number;
  message?: string;
  details?: ProtobufAny[];
}

export interface Hooksv1PartnerParameters {
  enabled?: boolean;
  hookUrl?: string;
  jwtSecret?: string;
  hookCustomer?: boolean;
  hookOperation?: boolean;
  hookDepositAccount?: boolean;
  hookCounterparty?: boolean;
}

export type IntegrationFinanceProvider = typeof IntegrationFinanceProvider[keyof typeof IntegrationFinanceProvider];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IntegrationFinanceProvider = {
  UNSET: 'UNSET',
  LAYER2: 'LAYER2',
} as const;

export interface IntegrationapplicationAddress {
  unitNumber?: string;
  addressLine1?: string;
  addressLine2?: string;
  addressLine3?: string;
  city?: string;
  stateIso?: string;
  postalCode?: string;
  countryIso?: string;
}

export interface IntegrationapplicationCorporateCustomer {
  registeredName?: string;
  tradingName?: string;
  registeredNumber?: string;
  registeredAddress?: IntegrationapplicationAddress;
  physicalAddress?: IntegrationapplicationAddress;
  telephoneNumber?: string;
  websiteAddress?: string;
  stateOfIncorporation?: string;
  countryOfIncorporation?: string;
  corporateEntityType?: ApplicationEntityType;
  corporateEntityTypeDescription?: string;
  emailAddress?: string;
  establishedOn?: string;
  naics?: string;
  naicsDescription?: string;
  investmentProfile?: ApplicationCorporateInvestment;
  kycProfile?: ApplicationCorporateKyc;
  guid?: string;
  taxReferenceNumber?: string;
  reasons?: ApplicationCorporateReasons;
  documents?: IntegrationapplicationDocument[];
  informationAttested?: boolean;
  legalStructureDescription?: string;
}

export interface IntegrationapplicationDocument {
  guid?: string;
  status?: ApplicationDocumentStatus;
  type?: ApplicationDocumentType;
}

export interface IntegrationapplicationIndividualCustomer {
  firstName?: string;
  middleName?: string;
  lastName?: string;
  emailAddress?: string;
  mailingAddress?: IntegrationapplicationAddress;
  telephoneNumber?: string;
  taxReferenceNumber?: string;
  passportNumber?: string;
  nationality?: string;
  dateOfBirth?: string;
  usResidencyStatus?: ApplicationUsResident;
  employmentStatus?: ApplicationEmploymentStatus;
  employmentDescription?: string;
  employerName?: string;
  occupation?: string;
  investmentProfile?: ApplicationIndividualInvestment;
  kycProfile?: ApplicationIndividualKyc;
  guid?: string;
  documents?: IntegrationapplicationDocument[];
  informationAttested?: boolean;
}

export interface IntegrationapplicationIndividualProfile {
  individualType?: ApplicationIndividuals[];
  firstName?: string;
  middleName?: string;
  lastName?: string;
  emailAddress?: string;
  mailingAddress?: IntegrationapplicationAddress;
  telephoneNumber?: string;
  taxReferenceNumber?: string;
  passportNumber?: string;
  nationality?: string;
  dateOfBirth?: string;
  percentageOwnership?: number;
  title?: string;
  usResidencyStatus?: ApplicationUsResident;
  guid?: string;
  documents?: IntegrationapplicationDocument[];
}

export interface MessageCreateTemplateRequest {
  typeId: number;
  subject: string;
  title: string;
  content?: string;
  button?: string;
  link?: string;
  delay?: string;
  showTime?: string;
  triggers?: V1Trigger[];
}

export interface MessageGetTemplateResponse {
  item?: V2messageTemplate;
}

export interface MessageGetTemplatesResponse {
  items?: V2messageTemplate[];
  meta?: V2ListMeta;
}

export interface MessageSettingResponse {
  settings?: MessageSettings;
}

export interface MessageSettingUpdateRequest {
  settings?: MessageSettings;
}

export interface MessageSettings {
  common?: V1CommonSetting;
  email?: V1EmailSetting;
}

export interface Messagesv1SuccessResponse {
  success?: boolean;
}

/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.

Protobuf library provides support to pack/unpack Any values in the form
of utility functions or additional generated methods of the Any type.

Example 1: Pack and unpack a message in C++.

    Foo foo = ...;
    Any any;
    any.PackFrom(foo);
    ...
    if (any.UnpackTo(&foo)) {
      ...
    }

Example 2: Pack and unpack a message in Java.

    Foo foo = ...;
    Any any = Any.pack(foo);
    ...
    if (any.is(Foo.class)) {
      foo = any.unpack(Foo.class);
    }
    // or ...
    if (any.isSameTypeAs(Foo.getDefaultInstance())) {
      foo = any.unpack(Foo.getDefaultInstance());
    }

 Example 3: Pack and unpack a message in Python.

    foo = Foo(...)
    any = Any()
    any.Pack(foo)
    ...
    if any.Is(Foo.DESCRIPTOR):
      any.Unpack(foo)
      ...

 Example 4: Pack and unpack a message in Go

     foo := &pb.Foo{...}
     any, err := anypb.New(foo)
     if err != nil {
       ...
     }
     ...
     foo := &pb.Foo{}
     if err := any.UnmarshalTo(foo); err != nil {
       ...
     }

The pack methods provided by protobuf library will by default use
'type.googleapis.com/full.type.name' as the type URL and the unpack
methods only use the fully qualified type name after the last '/'
in the type URL, for example "foo.bar.com/x/y.z" will yield type
name "y.z".

JSON
====
The JSON representation of an `Any` value uses the regular
representation of the deserialized, embedded message, with an
additional field `@type` which contains the type URL. Example:

    package google.profile;
    message Person {
      string first_name = 1;
      string last_name = 2;
    }

    {
      "@type": "type.googleapis.com/google.profile.Person",
      "firstName": <string>,
      "lastName": <string>
    }

If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
`value` which holds the custom JSON in addition to the `@type`
field. Example (for message [google.protobuf.Duration][]):

    {
      "@type": "type.googleapis.com/google.protobuf.Duration",
      "value": "1.212s"
    }
 */
export interface ProtobufAny {
  /** A URL/resource name that uniquely identifies the type of the serialized
protocol buffer message. This string must contain at least
one "/" character. The last segment of the URL's path must represent
the fully qualified name of the type (as in
`path/google.protobuf.Duration`). The name should be in a canonical form
(e.g., leading "." is not accepted).

In practice, teams usually precompile into the binary all types that they
expect it to use in the context of Any. However, for URLs which use the
scheme `http`, `https`, or no scheme, one can optionally set up a type
server that maps type URLs to message definitions as follows:

* If no scheme is provided, `https` is assumed.
* An HTTP GET on the URL must yield a [google.protobuf.Type][]
  value in binary format, or produce an error.
* Applications are allowed to cache lookup results based on the
  URL, or have them precompiled into a binary to avoid any
  lookup. Therefore, binary compatibility needs to be preserved
  on changes to types. (Use versioned type names to manage
  breaking changes.)

Note: this functionality is not currently available in the official
protobuf release, and it is not used for type URLs beginning with
type.googleapis.com. As of May 2023, there are no widely used type server
implementations and no plans to implement one.

Schemes other than `http`, `https` (or the empty scheme) might be
used with implementation specific semantics. */
  '@type'?: string;
  [key: string]: unknown;
}

export interface SearchSearchResponse {
  allCount?: string;
}

export interface TypeExportOption {
  format?: TypeExportOptionFormat;
}

export type TypeExportOptionFormat = typeof TypeExportOptionFormat[keyof typeof TypeExportOptionFormat];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TypeExportOptionFormat = {
  Unknown: 'Unknown',
  PDF: 'PDF',
  XLSX: 'XLSX',
} as const;

/**
 * Represents an amount of money with its currency type.
 */
export interface TypeMoney {
  /** The three-letter currency code defined in ISO 4217. */
  currencyCode?: string;
  /** The whole units of the amount.
For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar. */
  units?: string;
  /** Number of nano (10^-9) units of the amount.
The value must be between -999,999,999 and +999,999,999 inclusive.
If `units` is positive, `nanos` must be positive or zero.
If `units` is zero, `nanos` can be positive, zero, or negative.
If `units` is negative, `nanos` must be negative or zero.
For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000. */
  nanos?: number;
}

export interface UserCreateUserRequest {
  customerId?: string;
  username: string;
  password: string;
  name?: string;
  lastname?: string;
  comment?: string;
}

export interface UserFileListRespond {
  items?: V2userFile[];
  meta?: V2ListMeta;
}

export interface UserFileUpload {
  /** Customer ID */
  customerId?: string;
  /** Attached file for upload */
  attach: string;
}

export interface UserGetUserRespond {
  item?: UserUserDetail;
}

export interface UserListUserRespond {
  meta?: V2ListMeta;
  items?: V2userUser[];
}

export interface UserUploadResponse {
  file?: V2userFile;
}

export interface UserUserDetail {
  id?: number;
  userId?: string;
  username?: string;
  status?: UsersUserStatus;
  is2fa?: boolean;
  isDeleted?: boolean;
  partnerId?: string;
  createAt?: string;
  updateAt?: string;
  name?: string;
  lastname?: string;
  comment?: string;
  parameters?: UsersUserParameters;
  customers?: V2userRelationClient[];
}

export interface UserUserRespond {
  item?: V2userUser;
}

export type UserUserStatus = typeof UserUserStatus[keyof typeof UserUserStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserUserStatus = {
  NOT_SET: 'NOT_SET',
  NEW: 'NEW',
  READY_FOR_MODERATION: 'READY_FOR_MODERATION',
  MODERATED: 'MODERATED',
  VERIFY: 'VERIFY',
  ACCEPT: 'ACCEPT',
  REJECT: 'REJECT',
  BANNED: 'BANNED',
} as const;

export interface UserUsersUpdateBody {
  customerId?: string;
  password?: string;
  status?: UsersUserStatus;
  is2fa?: boolean;
  name?: string;
  lastname?: string;
  comment?: string;
}

export type UsersClientStatus = typeof UsersClientStatus[keyof typeof UsersClientStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UsersClientStatus = {
  NEW: 'NEW',
  READY_FOR_MODERATION: 'READY_FOR_MODERATION',
  MODERATED: 'MODERATED',
  VERIFY: 'VERIFY',
  ACCEPT: 'ACCEPT',
  REJECT: 'REJECT',
  BANNED: 'BANNED',
} as const;

export type UsersClientType = typeof UsersClientType[keyof typeof UsersClientType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UsersClientType = {
  CORPORATE: 'CORPORATE',
  INDIVIDUAL: 'INDIVIDUAL',
} as const;

export type UsersFileType = typeof UsersFileType[keyof typeof UsersFileType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UsersFileType = {
  UNSET: 'UNSET',
  LOGO: 'LOGO',
} as const;

export interface UsersMfaSettings {
  requireOtp?: boolean;
  requirePass?: boolean;
  requireEmail?: boolean;
  requireSms?: boolean;
}

export type UsersPartnerStatus = typeof UsersPartnerStatus[keyof typeof UsersPartnerStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UsersPartnerStatus = {
  NEW: 'NEW',
  READY_FOR_MODERATION: 'READY_FOR_MODERATION',
  MODERATED: 'MODERATED',
  VERIFY: 'VERIFY',
  ACCEPT: 'ACCEPT',
  REJECT: 'REJECT',
  BANNED: 'BANNED',
} as const;

export interface UsersUserParameters {
  mfa?: UsersMfaSettings;
  profile?: UsersUserProfile;
}

export interface UsersUserProfile {
  phone?: string;
  email?: string;
  dob?: string;
  country?: string;
  city?: string;
  postcode?: string;
}

export type UsersUserStatus = typeof UsersUserStatus[keyof typeof UsersUserStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UsersUserStatus = {
  NEW: 'NEW',
  READY_FOR_MODERATION: 'READY_FOR_MODERATION',
  MODERATED: 'MODERATED',
  VERIFY: 'VERIFY',
  ACCEPT: 'ACCEPT',
  REJECT: 'REJECT',
  BANNED: 'BANNED',
} as const;

export interface V1AccountCrypto {
  address?: string;
  additionalInformation?: V1CryptoAdditionalInformation;
}

export interface V1AccountFiat {
  number?: string;
  ifsc?: string;
  swift?: string;
  sortCode?: string;
  name?: string;
  transitNumber?: string;
  routingNumber?: string;
  additionalInformation?: V1FiatAdditionalInformation;
}

export interface V1AccountRequisitesItem {
  id?: string;
  requisiteId?: number;
  key?: string;
  value?: string;
  order?: number;
}

export interface V1Ammount {
  sum?: TypeMoney;
  default?: TypeMoney;
}

export interface V1CommonSetting {
  enabled?: boolean;
  appHostname?: string;
  frontHostname?: string;
  frontName?: string;
  companyName?: string;
  companyPhone?: string;
}

export interface V1Country {
  iso?: string;
  name?: string;
}

export interface V1CountryList {
  items?: V1Country[];
}

export interface V1CryptoAdditionalInformation {
  walletType?: CounterpartyCPWalletType;
  type?: CounterpartyCPType;
  supportedRails?: CounterpartyCPRails[];
}

export interface V1DateRange {
  from?: string;
  to?: string;
}

export interface V1EmailSetting {
  enabled?: boolean;
  emailAccount?: string;
  emailPassword?: string;
  smtpHost?: string;
  smtpPort?: number;
}

export interface V1Event {
  id?: number;
  Name?: string;
  variables?: V1EventVariable[];
}

export interface V1EventVariable {
  name?: string;
}

export interface V1ExportResponse {
  data?: string;
  name?: string;
}

export interface V1FiatAdditionalInformation {
  type?: CounterpartyCPType;
  supportedRails?: CounterpartyCPRails[];
  intermediary?: V1Intermediary;
  accountType?: CounterpartyCPAccountType;
}

export interface V1Intermediary {
  type?: CounterpartyCPType;
  bank?: Delosbeneficiaryv1BankInfo;
}

export interface V1NotificationType {
  id?: number;
  name?: string;
  isAllowed?: boolean;
}

export type V1OperationStatus = typeof V1OperationStatus[keyof typeof V1OperationStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1OperationStatus = {
  NEW: 'NEW',
  PENDING: 'PENDING',
  WORKING: 'WORKING',
  SUCCESS: 'SUCCESS',
  FAIL: 'FAIL',
  CANCELED: 'CANCELED',
} as const;

export interface V1Trigger {
  eventId?: number;
  templateId?: number;
  event?: V1Event;
}

export interface V2ListMeta {
  pageSize?: number;
  page?: number;
  total?: string;
}

export interface V2QueryMeta {
  pageSize?: number;
  page?: number;
}

export interface V2RespondStatus {
  success?: boolean;
  message?: string;
}

export interface V2accountAccount {
  accountId?: string;
  customer?: AccountAccountCustomer;
  isDefault?: boolean;
  name?: string;
  status?: Delosaccountsv1AccountStatus;
  balance?: AccountAccountBalance;
  currencyCode?: string;
  requisites?: V2accountAccountRequisites[];
  createdAt?: string;
  updatedAt?: string;
}

export interface V2accountAccountRequisites {
  title?: string;
  id?: number;
  items?: V1AccountRequisitesItem[];
}

export interface V2authPartner {
  id?: string;
  name?: string;
  status?: UsersPartnerStatus;
  logo?: DelosusersFile;
}

export interface V2authProfile {
  partner?: AuthProfilePartner;
  user?: AuthProfileUser;
}

export interface V2billingCommissionAccount {
  currencyCode?: string;
  poolAccountId?: string;
  commissionAccountId?: string;
}

export interface V2billingCurrencyCommission {
  currencyCodeFrom?: string;
  currencyCodeTo?: string;
  operationType?: Billingv1OperationType;
  paymentType?: Billingv1PaymentType;
  commission?: BillingCurrencyCommissionCommission;
  createdAt?: string;
  updatedAt?: string;
  customerId?: string;
  customerName?: string;
}

export interface V2billingLimit {
  id?: number;
  owner?: number;
  currencyCodeFrom?: string;
  currencyCodeTo?: string;
  operationType?: Billingv1OperationType;
  paymentType?: Billingv1PaymentType;
  min?: number;
  max?: number;
  createdAt?: string;
  updatedAt?: string;
  customerName?: string;
  customerId?: string;
}

/**
 * Set oneof: Deposit Account ID or Beneficiar (counterparty) Account ID.
<br>For Source:
<br>- Must be set Deposit Account ID.
<br>For Destination, one of:
<br>- Deposit Account ID if operation is EXCHANGE, TRANSFER, DEPOSIT.
<br>- Beneficiar (counterparty) Account ID if operation is WITHDRAW.
 */
export interface V2billingRequisit {
  /** Deposit Account unique id. */
  account?: string;
  /** Beneficiar (counterparty) Account unique id. */
  beneficiar?: string;
}

export interface V2billingSetCommissionRequest {
  customerId?: string;
  currencyCodeFrom?: string;
  currencyCodeTo?: string;
  operationType?: Billingv1OperationType;
  paymentType?: Billingv1PaymentType;
  percent?: number;
  fixed?: number;
}

export interface V2counterpartyCounterparty {
  counterpartyId?: string;
  customer?: CounterpartyCustomerV2;
  description?: string;
  profile?: V2counterpartyCounterpartyProfile;
  createdAt?: string;
  updatedAt?: string;
}

export interface V2counterpartyCounterpartyAccount {
  readonly accountId?: string;
  currencyCode?: string;
  status?: Delosbeneficiaryv1AccountStatus;
  bank?: Delosbeneficiaryv1BankInfo;
  crypto?: V1AccountCrypto;
  fiat?: V1AccountFiat;
}

export interface V2counterpartyCounterpartyProfile {
  name: string;
  email?: string;
  phoneNumber?: string;
  taxNumber?: string;
  dateOfBirth?: string;
  address: Delosbeneficiaryv1Address;
  website?: string;
  additionalInfo?: CounterpartyProfileAdditionalInfo;
  lastname?: string;
}

export interface V2counterpartyCustomer {
  id?: string;
  name?: string;
  email?: string;
  phone?: string;
  status?: UsersClientStatus;
}

export interface V2customerCorporateCustomer {
  registeredName?: string;
  tradingName?: string;
  registeredNumber?: string;
  registeredAddress?: IntegrationapplicationAddress;
  physicalAddress?: IntegrationapplicationAddress;
  telephoneNumber?: string;
  websiteAddress?: string;
  stateOfIncorporation?: string;
  countryOfIncorporation?: string;
  corporateEntityType?: ApplicationEntityType;
  corporateEntityTypeDescription?: string;
  emailAddress?: string;
  establishedOn?: string;
  naics?: string;
  naicsDescription?: string;
  investmentProfile?: ApplicationCorporateInvestment;
  kycProfile?: ApplicationCorporateKyc;
  guid?: string;
  taxReferenceNumber?: string;
  reasons?: ApplicationCorporateReasons;
  documents?: Gatewayv2Document[];
  informationAttested?: boolean;
  legalStructureDescription?: string;
}

export interface V2customerDocumentListRespond {
  items?: Gatewayv2Document[];
  meta?: V2ListMeta;
}

export interface V2customerIndividualCustomer {
  firstName?: string;
  middleName?: string;
  lastName?: string;
  emailAddress?: string;
  mailingAddress?: IntegrationapplicationAddress;
  telephoneNumber?: string;
  taxReferenceNumber?: string;
  passportNumber?: string;
  nationality?: string;
  dateOfBirth?: string;
  usResidencyStatus?: ApplicationUsResident;
  employmentStatus?: ApplicationEmploymentStatus;
  employmentDescription?: string;
  employerName?: string;
  occupation?: string;
  investmentProfile?: ApplicationIndividualInvestment;
  kycProfile?: ApplicationIndividualKyc;
  guid?: string;
  documents?: Gatewayv2Document[];
  informationAttested?: boolean;
}

export interface V2customerIndividualProfile {
  individualType?: ApplicationIndividuals[];
  firstName?: string;
  middleName?: string;
  lastName?: string;
  emailAddress?: string;
  mailingAddress?: IntegrationapplicationAddress;
  telephoneNumber?: string;
  taxReferenceNumber?: string;
  passportNumber?: string;
  nationality?: string;
  dateOfBirth?: string;
  percentageOwnership?: number;
  title?: string;
  usResidencyStatus?: ApplicationUsResident;
  guid?: string;
  documents?: Gatewayv2Document[];
}

export type V2customerStatus = typeof V2customerStatus[keyof typeof V2customerStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V2customerStatus = {
  STATUS_NOT_SET: 'STATUS_NOT_SET',
  NEW: 'NEW',
  READY_FOR_MODERATION: 'READY_FOR_MODERATION',
  MODERATED: 'MODERATED',
  VERIFY: 'VERIFY',
  ACCEPT: 'ACCEPT',
  REJECT: 'REJECT',
  BANNED: 'BANNED',
} as const;

export type V2customerType = typeof V2customerType[keyof typeof V2customerType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V2customerType = {
  TYPE_NOT_SET: 'TYPE_NOT_SET',
  CORPORATE: 'CORPORATE',
  INDIVIDUAL: 'INDIVIDUAL',
} as const;

export interface V2hookPartnerUpdateRequest {
  parameters?: Hooksv1PartnerParameters;
}

export interface V2messageEventsResponse {
  items?: V1Event[];
  meta?: V2ListMeta;
}

export interface V2messageNotificationTypesResponse {
  items?: V1NotificationType[];
  meta?: V2ListMeta;
}

export interface V2messageTemplate {
  id?: string;
  partnerId?: string;
  typeId?: number;
  subject?: string;
  title?: string;
  content?: string;
  button?: string;
  link?: string;
  updatedAt?: string;
  createdAt?: string;
  deletedAt?: string;
  delay?: string;
  isActive?: boolean;
  showTime?: string;
  triggers?: V1Trigger[];
}

export interface V2userFile {
  partnerId?: string;
  customerId?: string;
  id?: string;
  name?: string;
  size?: number;
  mime?: string;
  isLock?: boolean;
  createAt?: string;
  deletedAt?: string;
}

export interface V2userRelationClient {
  customerId?: string;
  isOwner?: boolean;
}

export interface V2userUser {
  userId?: string;
  username?: string;
  status?: UsersUserStatus;
  is2fa?: boolean;
  createAt?: string;
  updateAt?: string;
  name?: string;
  comment?: string;
}

export type Gatewayv2authOtpCodeRequestBody = Gatewayv2authOtpCodeRequest;

export type BillingCreateOperationRequestBody = BillingCreateOperationRequest;

export type AccountsGetAccountsParams = {
accountId?: string;
fromCreatedAt?: string;
toCreatedAt?: string;
customerId?: string;
customerName?: string;
name?: string;
status?: AccountsGetAccountsStatus;
currencyCode?: string;
balance?: AccountsGetAccountsBalance;
number?: string;
/**
 * Set items count per page
 */
'meta.pageSize'?: number;
/**
 * Page No. Starts from 0
 */
'meta.page'?: number;
withCommission?: boolean;
associateType?: AccountsGetAccountsAssociateType;
search?: string;
};

export type AccountsGetAccountsStatus = typeof AccountsGetAccountsStatus[keyof typeof AccountsGetAccountsStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountsGetAccountsStatus = {
  ACCOUNT_STATUS_NOTSET: 'ACCOUNT_STATUS_NOTSET',
  NEW: 'NEW',
  PRE_MODERATION: 'PRE_MODERATION',
  MODERATION: 'MODERATION',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED',
  BANNED: 'BANNED',
  PROCESSING: 'PROCESSING',
} as const;

export type AccountsGetAccountsBalance = typeof AccountsGetAccountsBalance[keyof typeof AccountsGetAccountsBalance];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountsGetAccountsBalance = {
  NOTSET: 'NOTSET',
  NEGATIVE: 'NEGATIVE',
  POSITIVE: 'POSITIVE',
  ZERO: 'ZERO',
} as const;

export type AccountsGetAccountsAssociateType = typeof AccountsGetAccountsAssociateType[keyof typeof AccountsGetAccountsAssociateType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountsGetAccountsAssociateType = {
  ASSOCIATE_TYPE_NOT_SET: 'ASSOCIATE_TYPE_NOT_SET',
  NOT_ASSOCIATE: 'NOT_ASSOCIATE',
  POOL: 'POOL',
  COMMISSION: 'COMMISSION',
} as const;

export type AuthUpdatePartnerParams = {
name?: string;
/**
 * @gotags: validate:"required"
 */
'logo.id'?: string;
/**
 * @gotags: validate:"required"
 */
'logo.name'?: string;
};

export type BillingGetCommissionsParams = {
currencyCodeFrom?: string;
currencyCodeTo?: string;
/**
 *  - NOTSET: service type
 */
operationType?: BillingGetCommissionsOperationType;
/**
 *  - EMPTY: service type
 */
paymentType?: BillingGetCommissionsPaymentType;
fromCreatedAt?: string;
toCreatedAt?: string;
fromUpdatedAt?: string;
toUpdatedAt?: string;
customerId?: string;
customerName?: string;
withAllCustomers?: boolean;
};

export type BillingGetCommissionsOperationType = typeof BillingGetCommissionsOperationType[keyof typeof BillingGetCommissionsOperationType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BillingGetCommissionsOperationType = {
  NOTSET: 'NOTSET',
  DEPOSIT: 'DEPOSIT',
  TRANSFER: 'TRANSFER',
  WITHDRAW: 'WITHDRAW',
  COMMISSION: 'COMMISSION',
  EXCHANGE: 'EXCHANGE',
  CORRECTING: 'CORRECTING',
} as const;

export type BillingGetCommissionsPaymentType = typeof BillingGetCommissionsPaymentType[keyof typeof BillingGetCommissionsPaymentType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BillingGetCommissionsPaymentType = {
  PAYMENT_TYPE_NOT_SET: 'PAYMENT_TYPE_NOT_SET',
  EMPTY: 'EMPTY',
  ACH: 'ACH',
  FEDWIRE: 'FEDWIRE',
  SWIFT: 'SWIFT',
  CRYPTO: 'CRYPTO',
  EFT: 'EFT',
  SEPA_CT: 'SEPA_CT',
  IMPS: 'IMPS',
} as const;

export type BillingListLimitsParams = {
/**
 * Set items count per page
 */
'meta.pageSize'?: number;
/**
 * Page No. Starts from 0
 */
'meta.page'?: number;
currencyCodeFrom?: string;
currencyCodeTo?: string;
/**
 *  - NOTSET: service type
 */
operationType?: BillingListLimitsOperationType;
/**
 *  - EMPTY: service type
 */
paymentType?: BillingListLimitsPaymentType;
customerId?: string;
fromCreatedAt?: string;
toCreatedAt?: string;
fromUpdatedAt?: string;
toUpdatedAt?: string;
withAllCustomers?: boolean;
};

export type BillingListLimitsOperationType = typeof BillingListLimitsOperationType[keyof typeof BillingListLimitsOperationType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BillingListLimitsOperationType = {
  NOTSET: 'NOTSET',
  DEPOSIT: 'DEPOSIT',
  TRANSFER: 'TRANSFER',
  WITHDRAW: 'WITHDRAW',
  COMMISSION: 'COMMISSION',
  EXCHANGE: 'EXCHANGE',
  CORRECTING: 'CORRECTING',
} as const;

export type BillingListLimitsPaymentType = typeof BillingListLimitsPaymentType[keyof typeof BillingListLimitsPaymentType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BillingListLimitsPaymentType = {
  PAYMENT_TYPE_NOT_SET: 'PAYMENT_TYPE_NOT_SET',
  EMPTY: 'EMPTY',
  ACH: 'ACH',
  FEDWIRE: 'FEDWIRE',
  SWIFT: 'SWIFT',
  CRYPTO: 'CRYPTO',
  EFT: 'EFT',
  SEPA_CT: 'SEPA_CT',
  IMPS: 'IMPS',
} as const;

export type BillingListParams = {
/**
 * Set items count per page
 */
'meta.pageSize'?: number;
/**
 * Page No. Starts from 0
 */
'meta.page'?: number;
fromCreatedAt?: string;
toCreatedAt?: string;
fromUpdatedAt?: string;
toUpdatedAt?: string;
customerId?: string;
customerName?: string;
operationId?: string;
source?: string;
destination?: string;
/**
 *  - NEW: Create by user or modrator
 - PENDING: Move by moderator to this status if operation ok
 - WORKING: Move by network for work
 - SUCCESS: Result status
 - FAIL: Result status
 - CANCELED: Result status
 */
status?: BillingListStatus;
/**
 *  - NOTSET: service type
 */
type?: BillingListType;
counterpartyAccountId?: string;
account?: string;
senderId?: string;
senderName?: string;
recipientId?: string;
recipientName?: string;
};

export type BillingListStatus = typeof BillingListStatus[keyof typeof BillingListStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BillingListStatus = {
  NOT_SET: 'NOT_SET',
  NEW: 'NEW',
  PENDING: 'PENDING',
  WORKING: 'WORKING',
  SUCCESS: 'SUCCESS',
  FAIL: 'FAIL',
  CANCELED: 'CANCELED',
} as const;

export type BillingListType = typeof BillingListType[keyof typeof BillingListType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BillingListType = {
  NOTSET: 'NOTSET',
  DEPOSIT: 'DEPOSIT',
  TRANSFER: 'TRANSFER',
  WITHDRAW: 'WITHDRAW',
  COMMISSION: 'COMMISSION',
  EXCHANGE: 'EXCHANGE',
} as const;

export type CounterpartiesGetListParams = {
/**
 * Set items count per page
 */
'meta.pageSize'?: number;
/**
 * Page No. Starts from 0
 */
'meta.page'?: number;
customerId?: string;
fromCreatedAt?: string;
toCreatedAt?: string;
customerName?: string;
counterpartyId?: string;
counterpartyName?: string;
};

export type CounterpartiesGetAccountListParams = {
fromCreatedAt?: string;
toCreatedAt?: string;
customerId?: string;
customerName?: string;
counterpartyId?: string;
counterpartyName?: string;
accountId?: string;
name?: string;
number?: string;
status?: CounterpartiesGetAccountListStatus;
currencyCode?: string;
/**
 * Set items count per page
 */
'meta.pageSize'?: number;
/**
 * Page No. Starts from 0
 */
'meta.page'?: number;
search?: string;
};

export type CounterpartiesGetAccountListStatus = typeof CounterpartiesGetAccountListStatus[keyof typeof CounterpartiesGetAccountListStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CounterpartiesGetAccountListStatus = {
  NEW: 'NEW',
  AWAIT: 'AWAIT',
  MODERATION: 'MODERATION',
  ACCEPT: 'ACCEPT',
  REJECT: 'REJECT',
  BANNED: 'BANNED',
  VERIFICATION: 'VERIFICATION',
} as const;

export type CustomerListParams = {
/**
 * Set items count per page
 */
'meta.pageSize'?: number;
/**
 * Page No. Starts from 0
 */
'meta.page'?: number;
type?: CustomerListType;
fromCreateAt?: string;
toCreateAt?: string;
/**
 *  - NEW: Registered user
 - MODERATED: Send to moderator
 - VERIFY: In verify state (working status)
 */
status?: CustomerListStatus;
customerId?: string;
customerName?: string;
userId?: string;
};

export type CustomerListType = typeof CustomerListType[keyof typeof CustomerListType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CustomerListType = {
  TYPE_NOT_SET: 'TYPE_NOT_SET',
  CORPORATE: 'CORPORATE',
  INDIVIDUAL: 'INDIVIDUAL',
} as const;

export type CustomerListStatus = typeof CustomerListStatus[keyof typeof CustomerListStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CustomerListStatus = {
  STATUS_NOT_SET: 'STATUS_NOT_SET',
  NEW: 'NEW',
  READY_FOR_MODERATION: 'READY_FOR_MODERATION',
  MODERATED: 'MODERATED',
  VERIFY: 'VERIFY',
  ACCEPT: 'ACCEPT',
  REJECT: 'REJECT',
  BANNED: 'BANNED',
} as const;

export type CustomerListDocumentsParams = {
/**
 * Set items count per page
 */
'meta.pageSize'?: number;
/**
 * Page No. Starts from 0
 */
'meta.page'?: number;
};

export type GeoStatesListParams = {
/**
 * Set items count per page
 */
'meta.pageSize'?: number;
/**
 * Page No. Starts from 0
 */
'meta.page'?: number;
/**
 * Optional filter
 */
filter?: string;
};

export type MessagesGetEventsParams = {
/**
 * Set items count per page
 */
'meta.pageSize'?: number;
/**
 * Page No. Starts from 0
 */
'meta.page'?: number;
};

export type MessagesGetTemplatesParams = {
/**
 * Set items count per page
 */
'meta.pageSize'?: number;
/**
 * Page No. Starts from 0
 */
'meta.page'?: number;
};

export type MessagesGetNotificationTypesParams = {
/**
 * Set items count per page
 */
'meta.pageSize'?: number;
/**
 * Page No. Starts from 0
 */
'meta.page'?: number;
};

export type ReportAccountRequisitesParams = {
'option.format'?: ReportAccountRequisitesOptionFormat;
};

export type ReportAccountRequisitesOptionFormat = typeof ReportAccountRequisitesOptionFormat[keyof typeof ReportAccountRequisitesOptionFormat];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReportAccountRequisitesOptionFormat = {
  Unknown: 'Unknown',
  PDF: 'PDF',
  XLSX: 'XLSX',
} as const;

export type ReportCounterpartyAccountRequisitesParams = {
'option.format'?: ReportCounterpartyAccountRequisitesOptionFormat;
};

export type ReportCounterpartyAccountRequisitesOptionFormat = typeof ReportCounterpartyAccountRequisitesOptionFormat[keyof typeof ReportCounterpartyAccountRequisitesOptionFormat];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReportCounterpartyAccountRequisitesOptionFormat = {
  Unknown: 'Unknown',
  PDF: 'PDF',
  XLSX: 'XLSX',
} as const;

export type ReportOperationListParams = {
pageSize?: number;
page?: number;
sortAttribute?: string;
sort?: ReportOperationListSort;
select?: string[];
};

export type ReportOperationListSort = typeof ReportOperationListSort[keyof typeof ReportOperationListSort];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReportOperationListSort = {
  ASC: 'ASC',
  DESC: 'DESC',
} as const;

export type ReportAccountStatementParams = {
/**
 * @gotags: validate:"required"
 */
accountId?: string;
'period.from'?: string;
'period.to'?: string;
'option.format'?: ReportAccountStatementOptionFormat;
};

export type ReportAccountStatementOptionFormat = typeof ReportAccountStatementOptionFormat[keyof typeof ReportAccountStatementOptionFormat];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReportAccountStatementOptionFormat = {
  Unknown: 'Unknown',
  PDF: 'PDF',
  XLSX: 'XLSX',
} as const;

export type StorageListParams = {
/**
 * Customer ID
 */
customerId?: string;
/**
 * Set items count per page
 */
'meta.pageSize'?: number;
/**
 * Page No. Starts from 0
 */
'meta.page'?: number;
};

export type StorageDownloadParams = {
/**
 * Customer ID
 */
customerId?: string;
};

export type StorageDeleteParams = {
/**
 * Customer ID
 */
customerId?: string;
};

export type UsersListParams = {
userId?: string;
name?: string;
fromCreateAt?: string;
toCreateAt?: string;
customerId?: string;
customerName?: string;
email?: string;
phone?: string;
/**
 *  - NEW: Registered user
 - MODERATED: Send to moderator
 - VERIFY: Send to moderator
 */
status?: UsersListStatus;
/**
 * Set items count per page
 */
'meta.pageSize'?: number;
/**
 * Page No. Starts from 0
 */
'meta.page'?: number;
};

export type UsersListStatus = typeof UsersListStatus[keyof typeof UsersListStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UsersListStatus = {
  NOT_SET: 'NOT_SET',
  NEW: 'NEW',
  READY_FOR_MODERATION: 'READY_FOR_MODERATION',
  MODERATED: 'MODERATED',
  VERIFY: 'VERIFY',
  ACCEPT: 'ACCEPT',
  REJECT: 'REJECT',
  BANNED: 'BANNED',
} as const;

export type UsersDeleteParams = {
customerId?: string;
};

export type UsersRemoveRelationClientParams = {
isOwner?: boolean;
};

/**
 * @summary Get account list
 */
export const accountsGetAccounts = (
    params?: AccountsGetAccountsParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AccountAccountsResponse>(
      {url: `/v2/account`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getAccountsGetAccountsQueryKey = (params?: AccountsGetAccountsParams,) => {
    return [
    `/v2/account`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getAccountsGetAccountsQueryOptions = <TData = Awaited<ReturnType<typeof accountsGetAccounts>>, TError = GooglerpcStatus>(params?: AccountsGetAccountsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof accountsGetAccounts>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAccountsGetAccountsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof accountsGetAccounts>>> = ({ signal }) => accountsGetAccounts(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof accountsGetAccounts>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AccountsGetAccountsQueryResult = NonNullable<Awaited<ReturnType<typeof accountsGetAccounts>>>
export type AccountsGetAccountsQueryError = GooglerpcStatus


export function useAccountsGetAccounts<TData = Awaited<ReturnType<typeof accountsGetAccounts>>, TError = GooglerpcStatus>(
 params: undefined |  AccountsGetAccountsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof accountsGetAccounts>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof accountsGetAccounts>>,
          TError,
          Awaited<ReturnType<typeof accountsGetAccounts>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAccountsGetAccounts<TData = Awaited<ReturnType<typeof accountsGetAccounts>>, TError = GooglerpcStatus>(
 params?: AccountsGetAccountsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof accountsGetAccounts>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof accountsGetAccounts>>,
          TError,
          Awaited<ReturnType<typeof accountsGetAccounts>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAccountsGetAccounts<TData = Awaited<ReturnType<typeof accountsGetAccounts>>, TError = GooglerpcStatus>(
 params?: AccountsGetAccountsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof accountsGetAccounts>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get account list
 */

export function useAccountsGetAccounts<TData = Awaited<ReturnType<typeof accountsGetAccounts>>, TError = GooglerpcStatus>(
 params?: AccountsGetAccountsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof accountsGetAccounts>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAccountsGetAccountsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create account
 */
export const accountsCreateAccount = (
    accountCreateAccountRequest: AccountCreateAccountRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AccountAccountResponse>(
      {url: `/v2/account`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: accountCreateAccountRequest, signal
    },
      );
    }
  


export const getAccountsCreateAccountMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof accountsCreateAccount>>, TError,{data: AccountCreateAccountRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof accountsCreateAccount>>, TError,{data: AccountCreateAccountRequest}, TContext> => {

const mutationKey = ['accountsCreateAccount'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof accountsCreateAccount>>, {data: AccountCreateAccountRequest}> = (props) => {
          const {data} = props ?? {};

          return  accountsCreateAccount(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AccountsCreateAccountMutationResult = NonNullable<Awaited<ReturnType<typeof accountsCreateAccount>>>
    export type AccountsCreateAccountMutationBody = AccountCreateAccountRequest
    export type AccountsCreateAccountMutationError = GooglerpcStatus

    /**
 * @summary Create account
 */
export const useAccountsCreateAccount = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof accountsCreateAccount>>, TError,{data: AccountCreateAccountRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof accountsCreateAccount>>,
        TError,
        {data: AccountCreateAccountRequest},
        TContext
      > => {

      const mutationOptions = getAccountsCreateAccountMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get account by ID
 */
export const accountsGetAccount = (
    accountId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AccountAccountResponse>(
      {url: `/v2/account/${accountId}`, method: 'GET', signal
    },
      );
    }
  



export const getAccountsGetAccountQueryKey = (accountId?: string,) => {
    return [
    `/v2/account/${accountId}`
    ] as const;
    }

    
export const getAccountsGetAccountQueryOptions = <TData = Awaited<ReturnType<typeof accountsGetAccount>>, TError = GooglerpcStatus>(accountId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof accountsGetAccount>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAccountsGetAccountQueryKey(accountId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof accountsGetAccount>>> = ({ signal }) => accountsGetAccount(accountId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(accountId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof accountsGetAccount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AccountsGetAccountQueryResult = NonNullable<Awaited<ReturnType<typeof accountsGetAccount>>>
export type AccountsGetAccountQueryError = GooglerpcStatus


export function useAccountsGetAccount<TData = Awaited<ReturnType<typeof accountsGetAccount>>, TError = GooglerpcStatus>(
 accountId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof accountsGetAccount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof accountsGetAccount>>,
          TError,
          Awaited<ReturnType<typeof accountsGetAccount>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAccountsGetAccount<TData = Awaited<ReturnType<typeof accountsGetAccount>>, TError = GooglerpcStatus>(
 accountId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof accountsGetAccount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof accountsGetAccount>>,
          TError,
          Awaited<ReturnType<typeof accountsGetAccount>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAccountsGetAccount<TData = Awaited<ReturnType<typeof accountsGetAccount>>, TError = GooglerpcStatus>(
 accountId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof accountsGetAccount>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get account by ID
 */

export function useAccountsGetAccount<TData = Awaited<ReturnType<typeof accountsGetAccount>>, TError = GooglerpcStatus>(
 accountId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof accountsGetAccount>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAccountsGetAccountQueryOptions(accountId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update account
 */
export const accountsUpdateAccount = (
    accountId: string,
    accountAccountsUpdateAccountBody: NonReadonly<AccountAccountsUpdateAccountBody>,
 ) => {
      
      
      return customInstance<AccountAccountResponse>(
      {url: `/v2/account/${accountId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: accountAccountsUpdateAccountBody
    },
      );
    }
  


export const getAccountsUpdateAccountMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof accountsUpdateAccount>>, TError,{accountId: string;data: NonReadonly<AccountAccountsUpdateAccountBody>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof accountsUpdateAccount>>, TError,{accountId: string;data: NonReadonly<AccountAccountsUpdateAccountBody>}, TContext> => {

const mutationKey = ['accountsUpdateAccount'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof accountsUpdateAccount>>, {accountId: string;data: NonReadonly<AccountAccountsUpdateAccountBody>}> = (props) => {
          const {accountId,data} = props ?? {};

          return  accountsUpdateAccount(accountId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AccountsUpdateAccountMutationResult = NonNullable<Awaited<ReturnType<typeof accountsUpdateAccount>>>
    export type AccountsUpdateAccountMutationBody = NonReadonly<AccountAccountsUpdateAccountBody>
    export type AccountsUpdateAccountMutationError = GooglerpcStatus

    /**
 * @summary Update account
 */
export const useAccountsUpdateAccount = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof accountsUpdateAccount>>, TError,{accountId: string;data: NonReadonly<AccountAccountsUpdateAccountBody>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof accountsUpdateAccount>>,
        TError,
        {accountId: string;data: NonReadonly<AccountAccountsUpdateAccountBody>},
        TContext
      > => {

      const mutationOptions = getAccountsUpdateAccountMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Login
 */
export const authLogin = (
    authLoginModel: AuthLoginModel,
 signal?: AbortSignal
) => {
      
      
      return customInstance<Gatewayv2authTokenRespond>(
      {url: `/v2/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: authLoginModel, signal
    },
      );
    }
  


export const getAuthLoginMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authLogin>>, TError,{data: AuthLoginModel}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof authLogin>>, TError,{data: AuthLoginModel}, TContext> => {

const mutationKey = ['authLogin'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authLogin>>, {data: AuthLoginModel}> = (props) => {
          const {data} = props ?? {};

          return  authLogin(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthLoginMutationResult = NonNullable<Awaited<ReturnType<typeof authLogin>>>
    export type AuthLoginMutationBody = AuthLoginModel
    export type AuthLoginMutationError = GooglerpcStatus

    /**
 * @summary Login
 */
export const useAuthLogin = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authLogin>>, TError,{data: AuthLoginModel}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authLogin>>,
        TError,
        {data: AuthLoginModel},
        TContext
      > => {

      const mutationOptions = getAuthLoginMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Otp Confirm
 */
export const authOtpConfirm = (
    gatewayv2authOtpCodeRequestBody: Gatewayv2authOtpCodeRequestBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AuthOtpRespond>(
      {url: `/v2/auth/otp/confirm`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: gatewayv2authOtpCodeRequestBody, signal
    },
      );
    }
  


export const getAuthOtpConfirmMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authOtpConfirm>>, TError,{data: Gatewayv2authOtpCodeRequestBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof authOtpConfirm>>, TError,{data: Gatewayv2authOtpCodeRequestBody}, TContext> => {

const mutationKey = ['authOtpConfirm'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authOtpConfirm>>, {data: Gatewayv2authOtpCodeRequestBody}> = (props) => {
          const {data} = props ?? {};

          return  authOtpConfirm(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthOtpConfirmMutationResult = NonNullable<Awaited<ReturnType<typeof authOtpConfirm>>>
    export type AuthOtpConfirmMutationBody = Gatewayv2authOtpCodeRequestBody
    export type AuthOtpConfirmMutationError = GooglerpcStatus

    /**
 * @summary Otp Confirm
 */
export const useAuthOtpConfirm = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authOtpConfirm>>, TError,{data: Gatewayv2authOtpCodeRequestBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authOtpConfirm>>,
        TError,
        {data: Gatewayv2authOtpCodeRequestBody},
        TContext
      > => {

      const mutationOptions = getAuthOtpConfirmMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Otp Disable
 */
export const authOtpDisable = (
    gatewayv2authOtpCodeRequestBody: Gatewayv2authOtpCodeRequestBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AuthOtpRespond>(
      {url: `/v2/auth/otp/disable`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: gatewayv2authOtpCodeRequestBody, signal
    },
      );
    }
  


export const getAuthOtpDisableMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authOtpDisable>>, TError,{data: Gatewayv2authOtpCodeRequestBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof authOtpDisable>>, TError,{data: Gatewayv2authOtpCodeRequestBody}, TContext> => {

const mutationKey = ['authOtpDisable'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authOtpDisable>>, {data: Gatewayv2authOtpCodeRequestBody}> = (props) => {
          const {data} = props ?? {};

          return  authOtpDisable(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthOtpDisableMutationResult = NonNullable<Awaited<ReturnType<typeof authOtpDisable>>>
    export type AuthOtpDisableMutationBody = Gatewayv2authOtpCodeRequestBody
    export type AuthOtpDisableMutationError = GooglerpcStatus

    /**
 * @summary Otp Disable
 */
export const useAuthOtpDisable = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authOtpDisable>>, TError,{data: Gatewayv2authOtpCodeRequestBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authOtpDisable>>,
        TError,
        {data: Gatewayv2authOtpCodeRequestBody},
        TContext
      > => {

      const mutationOptions = getAuthOtpDisableMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Otp Enable
 */
export const authOtpEnable = (
    authOtpEnableRequest: AuthOtpEnableRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AuthOtpQrRespond>(
      {url: `/v2/auth/otp/enable`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: authOtpEnableRequest, signal
    },
      );
    }
  


export const getAuthOtpEnableMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authOtpEnable>>, TError,{data: AuthOtpEnableRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof authOtpEnable>>, TError,{data: AuthOtpEnableRequest}, TContext> => {

const mutationKey = ['authOtpEnable'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authOtpEnable>>, {data: AuthOtpEnableRequest}> = (props) => {
          const {data} = props ?? {};

          return  authOtpEnable(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthOtpEnableMutationResult = NonNullable<Awaited<ReturnType<typeof authOtpEnable>>>
    export type AuthOtpEnableMutationBody = AuthOtpEnableRequest
    export type AuthOtpEnableMutationError = GooglerpcStatus

    /**
 * @summary Otp Enable
 */
export const useAuthOtpEnable = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authOtpEnable>>, TError,{data: AuthOtpEnableRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authOtpEnable>>,
        TError,
        {data: AuthOtpEnableRequest},
        TContext
      > => {

      const mutationOptions = getAuthOtpEnableMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get Partner
 */
export const authPartner = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<AuthPartnerRespond>(
      {url: `/v2/auth/partner`, method: 'GET', signal
    },
      );
    }
  



export const getAuthPartnerQueryKey = () => {
    return [
    `/v2/auth/partner`
    ] as const;
    }

    
export const getAuthPartnerQueryOptions = <TData = Awaited<ReturnType<typeof authPartner>>, TError = GooglerpcStatus>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authPartner>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthPartnerQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authPartner>>> = ({ signal }) => authPartner(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof authPartner>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AuthPartnerQueryResult = NonNullable<Awaited<ReturnType<typeof authPartner>>>
export type AuthPartnerQueryError = GooglerpcStatus


export function useAuthPartner<TData = Awaited<ReturnType<typeof authPartner>>, TError = GooglerpcStatus>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof authPartner>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authPartner>>,
          TError,
          Awaited<ReturnType<typeof authPartner>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthPartner<TData = Awaited<ReturnType<typeof authPartner>>, TError = GooglerpcStatus>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authPartner>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authPartner>>,
          TError,
          Awaited<ReturnType<typeof authPartner>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthPartner<TData = Awaited<ReturnType<typeof authPartner>>, TError = GooglerpcStatus>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authPartner>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Partner
 */

export function useAuthPartner<TData = Awaited<ReturnType<typeof authPartner>>, TError = GooglerpcStatus>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authPartner>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAuthPartnerQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update Partner
 */
export const authUpdatePartner = (
    params?: AuthUpdatePartnerParams,
 ) => {
      
      
      return customInstance<AuthPartnerRespond>(
      {url: `/v2/auth/partner`, method: 'PATCH',
        params
    },
      );
    }
  


export const getAuthUpdatePartnerMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authUpdatePartner>>, TError,{params?: AuthUpdatePartnerParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof authUpdatePartner>>, TError,{params?: AuthUpdatePartnerParams}, TContext> => {

const mutationKey = ['authUpdatePartner'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authUpdatePartner>>, {params?: AuthUpdatePartnerParams}> = (props) => {
          const {params} = props ?? {};

          return  authUpdatePartner(params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthUpdatePartnerMutationResult = NonNullable<Awaited<ReturnType<typeof authUpdatePartner>>>
    
    export type AuthUpdatePartnerMutationError = GooglerpcStatus

    /**
 * @summary Update Partner
 */
export const useAuthUpdatePartner = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authUpdatePartner>>, TError,{params?: AuthUpdatePartnerParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authUpdatePartner>>,
        TError,
        {params?: AuthUpdatePartnerParams},
        TContext
      > => {

      const mutationOptions = getAuthUpdatePartnerMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get Profile
 */
export const authProfile = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<AuthProfileRespond>(
      {url: `/v2/auth/profile`, method: 'GET', signal
    },
      );
    }
  



export const getAuthProfileQueryKey = () => {
    return [
    `/v2/auth/profile`
    ] as const;
    }

    
export const getAuthProfileQueryOptions = <TData = Awaited<ReturnType<typeof authProfile>>, TError = GooglerpcStatus>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authProfile>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthProfileQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authProfile>>> = ({ signal }) => authProfile(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof authProfile>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AuthProfileQueryResult = NonNullable<Awaited<ReturnType<typeof authProfile>>>
export type AuthProfileQueryError = GooglerpcStatus


export function useAuthProfile<TData = Awaited<ReturnType<typeof authProfile>>, TError = GooglerpcStatus>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof authProfile>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authProfile>>,
          TError,
          Awaited<ReturnType<typeof authProfile>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthProfile<TData = Awaited<ReturnType<typeof authProfile>>, TError = GooglerpcStatus>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authProfile>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authProfile>>,
          TError,
          Awaited<ReturnType<typeof authProfile>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthProfile<TData = Awaited<ReturnType<typeof authProfile>>, TError = GooglerpcStatus>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authProfile>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Profile
 */

export function useAuthProfile<TData = Awaited<ReturnType<typeof authProfile>>, TError = GooglerpcStatus>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authProfile>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAuthProfileQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Recovery Confirm
 */
export const authRecoveryAccessConfirm = (
    authConfirmRecoveryRequest: AuthConfirmRecoveryRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<DelosauthTokenRespond>(
      {url: `/v2/auth/recovery/confirm`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: authConfirmRecoveryRequest, signal
    },
      );
    }
  


export const getAuthRecoveryAccessConfirmMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authRecoveryAccessConfirm>>, TError,{data: AuthConfirmRecoveryRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof authRecoveryAccessConfirm>>, TError,{data: AuthConfirmRecoveryRequest}, TContext> => {

const mutationKey = ['authRecoveryAccessConfirm'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authRecoveryAccessConfirm>>, {data: AuthConfirmRecoveryRequest}> = (props) => {
          const {data} = props ?? {};

          return  authRecoveryAccessConfirm(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthRecoveryAccessConfirmMutationResult = NonNullable<Awaited<ReturnType<typeof authRecoveryAccessConfirm>>>
    export type AuthRecoveryAccessConfirmMutationBody = AuthConfirmRecoveryRequest
    export type AuthRecoveryAccessConfirmMutationError = GooglerpcStatus

    /**
 * @summary Recovery Confirm
 */
export const useAuthRecoveryAccessConfirm = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authRecoveryAccessConfirm>>, TError,{data: AuthConfirmRecoveryRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authRecoveryAccessConfirm>>,
        TError,
        {data: AuthConfirmRecoveryRequest},
        TContext
      > => {

      const mutationOptions = getAuthRecoveryAccessConfirmMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Recovery Access
 */
export const authRecoveryAccessRequest = (
    authRecoveryRequest: AuthRecoveryRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AuthRecoveryRespond>(
      {url: `/v2/auth/recovery/request`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: authRecoveryRequest, signal
    },
      );
    }
  


export const getAuthRecoveryAccessRequestMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authRecoveryAccessRequest>>, TError,{data: AuthRecoveryRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof authRecoveryAccessRequest>>, TError,{data: AuthRecoveryRequest}, TContext> => {

const mutationKey = ['authRecoveryAccessRequest'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authRecoveryAccessRequest>>, {data: AuthRecoveryRequest}> = (props) => {
          const {data} = props ?? {};

          return  authRecoveryAccessRequest(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthRecoveryAccessRequestMutationResult = NonNullable<Awaited<ReturnType<typeof authRecoveryAccessRequest>>>
    export type AuthRecoveryAccessRequestMutationBody = AuthRecoveryRequest
    export type AuthRecoveryAccessRequestMutationError = GooglerpcStatus

    /**
 * @summary Recovery Access
 */
export const useAuthRecoveryAccessRequest = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authRecoveryAccessRequest>>, TError,{data: AuthRecoveryRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authRecoveryAccessRequest>>,
        TError,
        {data: AuthRecoveryRequest},
        TContext
      > => {

      const mutationOptions = getAuthRecoveryAccessRequestMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Refresh Access Token
 */
export const authRefreshToken = (
    token: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<Gatewayv2authTokenRespond>(
      {url: `/v2/auth/refresh/${token}`, method: 'GET', signal
    },
      );
    }
  



export const getAuthRefreshTokenQueryKey = (token?: string,) => {
    return [
    `/v2/auth/refresh/${token}`
    ] as const;
    }

    
export const getAuthRefreshTokenQueryOptions = <TData = Awaited<ReturnType<typeof authRefreshToken>>, TError = GooglerpcStatus>(token: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authRefreshToken>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthRefreshTokenQueryKey(token);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authRefreshToken>>> = ({ signal }) => authRefreshToken(token, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(token), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof authRefreshToken>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AuthRefreshTokenQueryResult = NonNullable<Awaited<ReturnType<typeof authRefreshToken>>>
export type AuthRefreshTokenQueryError = GooglerpcStatus


export function useAuthRefreshToken<TData = Awaited<ReturnType<typeof authRefreshToken>>, TError = GooglerpcStatus>(
 token: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof authRefreshToken>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authRefreshToken>>,
          TError,
          Awaited<ReturnType<typeof authRefreshToken>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthRefreshToken<TData = Awaited<ReturnType<typeof authRefreshToken>>, TError = GooglerpcStatus>(
 token: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authRefreshToken>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authRefreshToken>>,
          TError,
          Awaited<ReturnType<typeof authRefreshToken>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthRefreshToken<TData = Awaited<ReturnType<typeof authRefreshToken>>, TError = GooglerpcStatus>(
 token: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authRefreshToken>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Refresh Access Token
 */

export function useAuthRefreshToken<TData = Awaited<ReturnType<typeof authRefreshToken>>, TError = GooglerpcStatus>(
 token: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authRefreshToken>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAuthRefreshTokenQueryOptions(token,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get Commissions
 */
export const billingGetCommissions = (
    params?: BillingGetCommissionsParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<BillingCurrencyCommissionListRespond>(
      {url: `/v2/billing/commission`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getBillingGetCommissionsQueryKey = (params?: BillingGetCommissionsParams,) => {
    return [
    `/v2/billing/commission`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getBillingGetCommissionsQueryOptions = <TData = Awaited<ReturnType<typeof billingGetCommissions>>, TError = GooglerpcStatus>(params?: BillingGetCommissionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingGetCommissions>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBillingGetCommissionsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof billingGetCommissions>>> = ({ signal }) => billingGetCommissions(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof billingGetCommissions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BillingGetCommissionsQueryResult = NonNullable<Awaited<ReturnType<typeof billingGetCommissions>>>
export type BillingGetCommissionsQueryError = GooglerpcStatus


export function useBillingGetCommissions<TData = Awaited<ReturnType<typeof billingGetCommissions>>, TError = GooglerpcStatus>(
 params: undefined |  BillingGetCommissionsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingGetCommissions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof billingGetCommissions>>,
          TError,
          Awaited<ReturnType<typeof billingGetCommissions>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBillingGetCommissions<TData = Awaited<ReturnType<typeof billingGetCommissions>>, TError = GooglerpcStatus>(
 params?: BillingGetCommissionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingGetCommissions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof billingGetCommissions>>,
          TError,
          Awaited<ReturnType<typeof billingGetCommissions>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBillingGetCommissions<TData = Awaited<ReturnType<typeof billingGetCommissions>>, TError = GooglerpcStatus>(
 params?: BillingGetCommissionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingGetCommissions>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Commissions
 */

export function useBillingGetCommissions<TData = Awaited<ReturnType<typeof billingGetCommissions>>, TError = GooglerpcStatus>(
 params?: BillingGetCommissionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingGetCommissions>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getBillingGetCommissionsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Set Commission
 */
export const billingSetCommission = (
    v2billingSetCommissionRequest: V2billingSetCommissionRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<BillingSetCommissionRespond>(
      {url: `/v2/billing/commission`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: v2billingSetCommissionRequest, signal
    },
      );
    }
  


export const getBillingSetCommissionMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof billingSetCommission>>, TError,{data: V2billingSetCommissionRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof billingSetCommission>>, TError,{data: V2billingSetCommissionRequest}, TContext> => {

const mutationKey = ['billingSetCommission'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof billingSetCommission>>, {data: V2billingSetCommissionRequest}> = (props) => {
          const {data} = props ?? {};

          return  billingSetCommission(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BillingSetCommissionMutationResult = NonNullable<Awaited<ReturnType<typeof billingSetCommission>>>
    export type BillingSetCommissionMutationBody = V2billingSetCommissionRequest
    export type BillingSetCommissionMutationError = GooglerpcStatus

    /**
 * @summary Set Commission
 */
export const useBillingSetCommission = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof billingSetCommission>>, TError,{data: V2billingSetCommissionRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof billingSetCommission>>,
        TError,
        {data: V2billingSetCommissionRequest},
        TContext
      > => {

      const mutationOptions = getBillingSetCommissionMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary List Commission Accounts
 */
export const billingGetCommissionAccounts = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<BillingCommissionAccountListRespond>(
      {url: `/v2/billing/commission/account`, method: 'GET', signal
    },
      );
    }
  



export const getBillingGetCommissionAccountsQueryKey = () => {
    return [
    `/v2/billing/commission/account`
    ] as const;
    }

    
export const getBillingGetCommissionAccountsQueryOptions = <TData = Awaited<ReturnType<typeof billingGetCommissionAccounts>>, TError = GooglerpcStatus>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingGetCommissionAccounts>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBillingGetCommissionAccountsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof billingGetCommissionAccounts>>> = ({ signal }) => billingGetCommissionAccounts(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof billingGetCommissionAccounts>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BillingGetCommissionAccountsQueryResult = NonNullable<Awaited<ReturnType<typeof billingGetCommissionAccounts>>>
export type BillingGetCommissionAccountsQueryError = GooglerpcStatus


export function useBillingGetCommissionAccounts<TData = Awaited<ReturnType<typeof billingGetCommissionAccounts>>, TError = GooglerpcStatus>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingGetCommissionAccounts>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof billingGetCommissionAccounts>>,
          TError,
          Awaited<ReturnType<typeof billingGetCommissionAccounts>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBillingGetCommissionAccounts<TData = Awaited<ReturnType<typeof billingGetCommissionAccounts>>, TError = GooglerpcStatus>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingGetCommissionAccounts>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof billingGetCommissionAccounts>>,
          TError,
          Awaited<ReturnType<typeof billingGetCommissionAccounts>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBillingGetCommissionAccounts<TData = Awaited<ReturnType<typeof billingGetCommissionAccounts>>, TError = GooglerpcStatus>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingGetCommissionAccounts>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Commission Accounts
 */

export function useBillingGetCommissionAccounts<TData = Awaited<ReturnType<typeof billingGetCommissionAccounts>>, TError = GooglerpcStatus>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingGetCommissionAccounts>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getBillingGetCommissionAccountsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary List Limits
 */
export const billingListLimits = (
    params?: BillingListLimitsParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<BillingLimitsListRespond>(
      {url: `/v2/billing/limits`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getBillingListLimitsQueryKey = (params?: BillingListLimitsParams,) => {
    return [
    `/v2/billing/limits`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getBillingListLimitsQueryOptions = <TData = Awaited<ReturnType<typeof billingListLimits>>, TError = GooglerpcStatus>(params?: BillingListLimitsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingListLimits>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBillingListLimitsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof billingListLimits>>> = ({ signal }) => billingListLimits(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof billingListLimits>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BillingListLimitsQueryResult = NonNullable<Awaited<ReturnType<typeof billingListLimits>>>
export type BillingListLimitsQueryError = GooglerpcStatus


export function useBillingListLimits<TData = Awaited<ReturnType<typeof billingListLimits>>, TError = GooglerpcStatus>(
 params: undefined |  BillingListLimitsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingListLimits>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof billingListLimits>>,
          TError,
          Awaited<ReturnType<typeof billingListLimits>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBillingListLimits<TData = Awaited<ReturnType<typeof billingListLimits>>, TError = GooglerpcStatus>(
 params?: BillingListLimitsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingListLimits>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof billingListLimits>>,
          TError,
          Awaited<ReturnType<typeof billingListLimits>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBillingListLimits<TData = Awaited<ReturnType<typeof billingListLimits>>, TError = GooglerpcStatus>(
 params?: BillingListLimitsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingListLimits>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Limits
 */

export function useBillingListLimits<TData = Awaited<ReturnType<typeof billingListLimits>>, TError = GooglerpcStatus>(
 params?: BillingListLimitsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingListLimits>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getBillingListLimitsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Set Limit
 */
export const billingSetLimit = (
    billingSetLimitRequest: BillingSetLimitRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<BillingSetLimitRespond>(
      {url: `/v2/billing/limits`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: billingSetLimitRequest, signal
    },
      );
    }
  


export const getBillingSetLimitMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof billingSetLimit>>, TError,{data: BillingSetLimitRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof billingSetLimit>>, TError,{data: BillingSetLimitRequest}, TContext> => {

const mutationKey = ['billingSetLimit'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof billingSetLimit>>, {data: BillingSetLimitRequest}> = (props) => {
          const {data} = props ?? {};

          return  billingSetLimit(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BillingSetLimitMutationResult = NonNullable<Awaited<ReturnType<typeof billingSetLimit>>>
    export type BillingSetLimitMutationBody = BillingSetLimitRequest
    export type BillingSetLimitMutationError = GooglerpcStatus

    /**
 * @summary Set Limit
 */
export const useBillingSetLimit = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof billingSetLimit>>, TError,{data: BillingSetLimitRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof billingSetLimit>>,
        TError,
        {data: BillingSetLimitRequest},
        TContext
      > => {

      const mutationOptions = getBillingSetLimitMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary List Operations
 */
export const billingList = (
    params?: BillingListParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<BillingListOperationRespond>(
      {url: `/v2/billing/operation`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getBillingListQueryKey = (params?: BillingListParams,) => {
    return [
    `/v2/billing/operation`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getBillingListQueryOptions = <TData = Awaited<ReturnType<typeof billingList>>, TError = GooglerpcStatus>(params?: BillingListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBillingListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof billingList>>> = ({ signal }) => billingList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof billingList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BillingListQueryResult = NonNullable<Awaited<ReturnType<typeof billingList>>>
export type BillingListQueryError = GooglerpcStatus


export function useBillingList<TData = Awaited<ReturnType<typeof billingList>>, TError = GooglerpcStatus>(
 params: undefined |  BillingListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof billingList>>,
          TError,
          Awaited<ReturnType<typeof billingList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBillingList<TData = Awaited<ReturnType<typeof billingList>>, TError = GooglerpcStatus>(
 params?: BillingListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof billingList>>,
          TError,
          Awaited<ReturnType<typeof billingList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBillingList<TData = Awaited<ReturnType<typeof billingList>>, TError = GooglerpcStatus>(
 params?: BillingListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Operations
 */

export function useBillingList<TData = Awaited<ReturnType<typeof billingList>>, TError = GooglerpcStatus>(
 params?: BillingListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getBillingListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Add Client Operation
 */
export const billingAdd = (
    billingCreateOperationRequestBody: BillingCreateOperationRequestBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<BillingOperationRespond>(
      {url: `/v2/billing/operation`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: billingCreateOperationRequestBody, signal
    },
      );
    }
  


export const getBillingAddMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof billingAdd>>, TError,{data: BillingCreateOperationRequestBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof billingAdd>>, TError,{data: BillingCreateOperationRequestBody}, TContext> => {

const mutationKey = ['billingAdd'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof billingAdd>>, {data: BillingCreateOperationRequestBody}> = (props) => {
          const {data} = props ?? {};

          return  billingAdd(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BillingAddMutationResult = NonNullable<Awaited<ReturnType<typeof billingAdd>>>
    export type BillingAddMutationBody = BillingCreateOperationRequestBody
    export type BillingAddMutationError = GooglerpcStatus

    /**
 * @summary Add Client Operation
 */
export const useBillingAdd = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof billingAdd>>, TError,{data: BillingCreateOperationRequestBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof billingAdd>>,
        TError,
        {data: BillingCreateOperationRequestBody},
        TContext
      > => {

      const mutationOptions = getBillingAddMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Prepare Client Operation
 */
export const billingPrepare = (
    billingCreateOperationRequestBody: BillingCreateOperationRequestBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<BillingOperationRespond>(
      {url: `/v2/billing/operation/prepare`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: billingCreateOperationRequestBody, signal
    },
      );
    }
  


export const getBillingPrepareMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof billingPrepare>>, TError,{data: BillingCreateOperationRequestBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof billingPrepare>>, TError,{data: BillingCreateOperationRequestBody}, TContext> => {

const mutationKey = ['billingPrepare'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof billingPrepare>>, {data: BillingCreateOperationRequestBody}> = (props) => {
          const {data} = props ?? {};

          return  billingPrepare(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BillingPrepareMutationResult = NonNullable<Awaited<ReturnType<typeof billingPrepare>>>
    export type BillingPrepareMutationBody = BillingCreateOperationRequestBody
    export type BillingPrepareMutationError = GooglerpcStatus

    /**
 * @summary Prepare Client Operation
 */
export const useBillingPrepare = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof billingPrepare>>, TError,{data: BillingCreateOperationRequestBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof billingPrepare>>,
        TError,
        {data: BillingCreateOperationRequestBody},
        TContext
      > => {

      const mutationOptions = getBillingPrepareMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get Operation
 */
export const billingGetOperation = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<BillingOperationRespond>(
      {url: `/v2/billing/operation/${id}`, method: 'GET', signal
    },
      );
    }
  



export const getBillingGetOperationQueryKey = (id?: string,) => {
    return [
    `/v2/billing/operation/${id}`
    ] as const;
    }

    
export const getBillingGetOperationQueryOptions = <TData = Awaited<ReturnType<typeof billingGetOperation>>, TError = GooglerpcStatus>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingGetOperation>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBillingGetOperationQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof billingGetOperation>>> = ({ signal }) => billingGetOperation(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof billingGetOperation>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BillingGetOperationQueryResult = NonNullable<Awaited<ReturnType<typeof billingGetOperation>>>
export type BillingGetOperationQueryError = GooglerpcStatus


export function useBillingGetOperation<TData = Awaited<ReturnType<typeof billingGetOperation>>, TError = GooglerpcStatus>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingGetOperation>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof billingGetOperation>>,
          TError,
          Awaited<ReturnType<typeof billingGetOperation>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBillingGetOperation<TData = Awaited<ReturnType<typeof billingGetOperation>>, TError = GooglerpcStatus>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingGetOperation>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof billingGetOperation>>,
          TError,
          Awaited<ReturnType<typeof billingGetOperation>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBillingGetOperation<TData = Awaited<ReturnType<typeof billingGetOperation>>, TError = GooglerpcStatus>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingGetOperation>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Operation
 */

export function useBillingGetOperation<TData = Awaited<ReturnType<typeof billingGetOperation>>, TError = GooglerpcStatus>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingGetOperation>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getBillingGetOperationQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Add document
 */
export const billingAddDocument = (
    id: string,
    billingAddDocumentBody: BillingAddDocumentBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<BillingOperationRespond>(
      {url: `/v2/billing/operation/${id}/document`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: billingAddDocumentBody, signal
    },
      );
    }
  


export const getBillingAddDocumentMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof billingAddDocument>>, TError,{id: string;data: BillingAddDocumentBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof billingAddDocument>>, TError,{id: string;data: BillingAddDocumentBody}, TContext> => {

const mutationKey = ['billingAddDocument'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof billingAddDocument>>, {id: string;data: BillingAddDocumentBody}> = (props) => {
          const {id,data} = props ?? {};

          return  billingAddDocument(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BillingAddDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof billingAddDocument>>>
    export type BillingAddDocumentMutationBody = BillingAddDocumentBody
    export type BillingAddDocumentMutationError = GooglerpcStatus

    /**
 * @summary Add document
 */
export const useBillingAddDocument = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof billingAddDocument>>, TError,{id: string;data: BillingAddDocumentBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof billingAddDocument>>,
        TError,
        {id: string;data: BillingAddDocumentBody},
        TContext
      > => {

      const mutationOptions = getBillingAddDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Remove Document
 */
export const billingRemoveDocument = (
    id: string,
    documentId: string,
 ) => {
      
      
      return customInstance<BillingOperationRespond>(
      {url: `/v2/billing/operation/${id}/document/${documentId}`, method: 'DELETE'
    },
      );
    }
  


export const getBillingRemoveDocumentMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof billingRemoveDocument>>, TError,{id: string;documentId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof billingRemoveDocument>>, TError,{id: string;documentId: string}, TContext> => {

const mutationKey = ['billingRemoveDocument'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof billingRemoveDocument>>, {id: string;documentId: string}> = (props) => {
          const {id,documentId} = props ?? {};

          return  billingRemoveDocument(id,documentId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BillingRemoveDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof billingRemoveDocument>>>
    
    export type BillingRemoveDocumentMutationError = GooglerpcStatus

    /**
 * @summary Remove Document
 */
export const useBillingRemoveDocument = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof billingRemoveDocument>>, TError,{id: string;documentId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof billingRemoveDocument>>,
        TError,
        {id: string;documentId: string},
        TContext
      > => {

      const mutationOptions = getBillingRemoveDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get Operation Tree
 */
export const billingGetTree = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<BillingOperationTreeRespond>(
      {url: `/v2/billing/operation/${id}/tree`, method: 'GET', signal
    },
      );
    }
  



export const getBillingGetTreeQueryKey = (id?: string,) => {
    return [
    `/v2/billing/operation/${id}/tree`
    ] as const;
    }

    
export const getBillingGetTreeQueryOptions = <TData = Awaited<ReturnType<typeof billingGetTree>>, TError = GooglerpcStatus>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingGetTree>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBillingGetTreeQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof billingGetTree>>> = ({ signal }) => billingGetTree(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof billingGetTree>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BillingGetTreeQueryResult = NonNullable<Awaited<ReturnType<typeof billingGetTree>>>
export type BillingGetTreeQueryError = GooglerpcStatus


export function useBillingGetTree<TData = Awaited<ReturnType<typeof billingGetTree>>, TError = GooglerpcStatus>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingGetTree>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof billingGetTree>>,
          TError,
          Awaited<ReturnType<typeof billingGetTree>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBillingGetTree<TData = Awaited<ReturnType<typeof billingGetTree>>, TError = GooglerpcStatus>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingGetTree>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof billingGetTree>>,
          TError,
          Awaited<ReturnType<typeof billingGetTree>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBillingGetTree<TData = Awaited<ReturnType<typeof billingGetTree>>, TError = GooglerpcStatus>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingGetTree>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Operation Tree
 */

export function useBillingGetTree<TData = Awaited<ReturnType<typeof billingGetTree>>, TError = GooglerpcStatus>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingGetTree>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getBillingGetTreeQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get counterparty list
 */
export const counterpartiesGetList = (
    params?: CounterpartiesGetListParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CounterpartyListCounterpartiesRespond>(
      {url: `/v2/counterparty`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getCounterpartiesGetListQueryKey = (params?: CounterpartiesGetListParams,) => {
    return [
    `/v2/counterparty`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getCounterpartiesGetListQueryOptions = <TData = Awaited<ReturnType<typeof counterpartiesGetList>>, TError = GooglerpcStatus>(params?: CounterpartiesGetListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof counterpartiesGetList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCounterpartiesGetListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof counterpartiesGetList>>> = ({ signal }) => counterpartiesGetList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof counterpartiesGetList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CounterpartiesGetListQueryResult = NonNullable<Awaited<ReturnType<typeof counterpartiesGetList>>>
export type CounterpartiesGetListQueryError = GooglerpcStatus


export function useCounterpartiesGetList<TData = Awaited<ReturnType<typeof counterpartiesGetList>>, TError = GooglerpcStatus>(
 params: undefined |  CounterpartiesGetListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof counterpartiesGetList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof counterpartiesGetList>>,
          TError,
          Awaited<ReturnType<typeof counterpartiesGetList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCounterpartiesGetList<TData = Awaited<ReturnType<typeof counterpartiesGetList>>, TError = GooglerpcStatus>(
 params?: CounterpartiesGetListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof counterpartiesGetList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof counterpartiesGetList>>,
          TError,
          Awaited<ReturnType<typeof counterpartiesGetList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCounterpartiesGetList<TData = Awaited<ReturnType<typeof counterpartiesGetList>>, TError = GooglerpcStatus>(
 params?: CounterpartiesGetListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof counterpartiesGetList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get counterparty list
 */

export function useCounterpartiesGetList<TData = Awaited<ReturnType<typeof counterpartiesGetList>>, TError = GooglerpcStatus>(
 params?: CounterpartiesGetListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof counterpartiesGetList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCounterpartiesGetListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create counterparty
 */
export const counterpartiesCreate = (
    counterpartyCreateCounterpartyRequest: CounterpartyCreateCounterpartyRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CounterpartyCounterpartyResponse>(
      {url: `/v2/counterparty`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: counterpartyCreateCounterpartyRequest, signal
    },
      );
    }
  


export const getCounterpartiesCreateMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof counterpartiesCreate>>, TError,{data: CounterpartyCreateCounterpartyRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof counterpartiesCreate>>, TError,{data: CounterpartyCreateCounterpartyRequest}, TContext> => {

const mutationKey = ['counterpartiesCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof counterpartiesCreate>>, {data: CounterpartyCreateCounterpartyRequest}> = (props) => {
          const {data} = props ?? {};

          return  counterpartiesCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CounterpartiesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof counterpartiesCreate>>>
    export type CounterpartiesCreateMutationBody = CounterpartyCreateCounterpartyRequest
    export type CounterpartiesCreateMutationError = GooglerpcStatus

    /**
 * @summary Create counterparty
 */
export const useCounterpartiesCreate = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof counterpartiesCreate>>, TError,{data: CounterpartyCreateCounterpartyRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof counterpartiesCreate>>,
        TError,
        {data: CounterpartyCreateCounterpartyRequest},
        TContext
      > => {

      const mutationOptions = getCounterpartiesCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get Account List
 */
export const counterpartiesGetAccountList = (
    params?: CounterpartiesGetAccountListParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CounterpartyCounterpartyAccountsResponseV2>(
      {url: `/v2/counterparty/account`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getCounterpartiesGetAccountListQueryKey = (params?: CounterpartiesGetAccountListParams,) => {
    return [
    `/v2/counterparty/account`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getCounterpartiesGetAccountListQueryOptions = <TData = Awaited<ReturnType<typeof counterpartiesGetAccountList>>, TError = GooglerpcStatus>(params?: CounterpartiesGetAccountListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof counterpartiesGetAccountList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCounterpartiesGetAccountListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof counterpartiesGetAccountList>>> = ({ signal }) => counterpartiesGetAccountList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof counterpartiesGetAccountList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CounterpartiesGetAccountListQueryResult = NonNullable<Awaited<ReturnType<typeof counterpartiesGetAccountList>>>
export type CounterpartiesGetAccountListQueryError = GooglerpcStatus


export function useCounterpartiesGetAccountList<TData = Awaited<ReturnType<typeof counterpartiesGetAccountList>>, TError = GooglerpcStatus>(
 params: undefined |  CounterpartiesGetAccountListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof counterpartiesGetAccountList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof counterpartiesGetAccountList>>,
          TError,
          Awaited<ReturnType<typeof counterpartiesGetAccountList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCounterpartiesGetAccountList<TData = Awaited<ReturnType<typeof counterpartiesGetAccountList>>, TError = GooglerpcStatus>(
 params?: CounterpartiesGetAccountListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof counterpartiesGetAccountList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof counterpartiesGetAccountList>>,
          TError,
          Awaited<ReturnType<typeof counterpartiesGetAccountList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCounterpartiesGetAccountList<TData = Awaited<ReturnType<typeof counterpartiesGetAccountList>>, TError = GooglerpcStatus>(
 params?: CounterpartiesGetAccountListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof counterpartiesGetAccountList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Account List
 */

export function useCounterpartiesGetAccountList<TData = Awaited<ReturnType<typeof counterpartiesGetAccountList>>, TError = GooglerpcStatus>(
 params?: CounterpartiesGetAccountListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof counterpartiesGetAccountList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCounterpartiesGetAccountListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get Account
 */
export const counterpartiesGetAccount = (
    accountId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CounterpartyCounterpartyAccountResponseV2>(
      {url: `/v2/counterparty/account/${accountId}`, method: 'GET', signal
    },
      );
    }
  



export const getCounterpartiesGetAccountQueryKey = (accountId?: string,) => {
    return [
    `/v2/counterparty/account/${accountId}`
    ] as const;
    }

    
export const getCounterpartiesGetAccountQueryOptions = <TData = Awaited<ReturnType<typeof counterpartiesGetAccount>>, TError = GooglerpcStatus>(accountId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof counterpartiesGetAccount>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCounterpartiesGetAccountQueryKey(accountId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof counterpartiesGetAccount>>> = ({ signal }) => counterpartiesGetAccount(accountId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(accountId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof counterpartiesGetAccount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CounterpartiesGetAccountQueryResult = NonNullable<Awaited<ReturnType<typeof counterpartiesGetAccount>>>
export type CounterpartiesGetAccountQueryError = GooglerpcStatus


export function useCounterpartiesGetAccount<TData = Awaited<ReturnType<typeof counterpartiesGetAccount>>, TError = GooglerpcStatus>(
 accountId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof counterpartiesGetAccount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof counterpartiesGetAccount>>,
          TError,
          Awaited<ReturnType<typeof counterpartiesGetAccount>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCounterpartiesGetAccount<TData = Awaited<ReturnType<typeof counterpartiesGetAccount>>, TError = GooglerpcStatus>(
 accountId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof counterpartiesGetAccount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof counterpartiesGetAccount>>,
          TError,
          Awaited<ReturnType<typeof counterpartiesGetAccount>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCounterpartiesGetAccount<TData = Awaited<ReturnType<typeof counterpartiesGetAccount>>, TError = GooglerpcStatus>(
 accountId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof counterpartiesGetAccount>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Account
 */

export function useCounterpartiesGetAccount<TData = Awaited<ReturnType<typeof counterpartiesGetAccount>>, TError = GooglerpcStatus>(
 accountId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof counterpartiesGetAccount>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCounterpartiesGetAccountQueryOptions(accountId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get counterparty
 */
export const counterpartiesGet = (
    counterpartyId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CounterpartyCounterpartyRespondV2>(
      {url: `/v2/counterparty/${counterpartyId}`, method: 'GET', signal
    },
      );
    }
  



export const getCounterpartiesGetQueryKey = (counterpartyId?: string,) => {
    return [
    `/v2/counterparty/${counterpartyId}`
    ] as const;
    }

    
export const getCounterpartiesGetQueryOptions = <TData = Awaited<ReturnType<typeof counterpartiesGet>>, TError = GooglerpcStatus>(counterpartyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof counterpartiesGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCounterpartiesGetQueryKey(counterpartyId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof counterpartiesGet>>> = ({ signal }) => counterpartiesGet(counterpartyId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(counterpartyId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof counterpartiesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CounterpartiesGetQueryResult = NonNullable<Awaited<ReturnType<typeof counterpartiesGet>>>
export type CounterpartiesGetQueryError = GooglerpcStatus


export function useCounterpartiesGet<TData = Awaited<ReturnType<typeof counterpartiesGet>>, TError = GooglerpcStatus>(
 counterpartyId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof counterpartiesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof counterpartiesGet>>,
          TError,
          Awaited<ReturnType<typeof counterpartiesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCounterpartiesGet<TData = Awaited<ReturnType<typeof counterpartiesGet>>, TError = GooglerpcStatus>(
 counterpartyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof counterpartiesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof counterpartiesGet>>,
          TError,
          Awaited<ReturnType<typeof counterpartiesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCounterpartiesGet<TData = Awaited<ReturnType<typeof counterpartiesGet>>, TError = GooglerpcStatus>(
 counterpartyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof counterpartiesGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get counterparty
 */

export function useCounterpartiesGet<TData = Awaited<ReturnType<typeof counterpartiesGet>>, TError = GooglerpcStatus>(
 counterpartyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof counterpartiesGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCounterpartiesGetQueryOptions(counterpartyId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update counterparty
 */
export const counterpartiesUpdate = (
    counterpartyId: string,
    counterpartyCounterpartiesUpdateBody: NonReadonly<CounterpartyCounterpartiesUpdateBody>,
 ) => {
      
      
      return customInstance<CounterpartyCounterpartyResponse>(
      {url: `/v2/counterparty/${counterpartyId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: counterpartyCounterpartiesUpdateBody
    },
      );
    }
  


export const getCounterpartiesUpdateMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof counterpartiesUpdate>>, TError,{counterpartyId: string;data: NonReadonly<CounterpartyCounterpartiesUpdateBody>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof counterpartiesUpdate>>, TError,{counterpartyId: string;data: NonReadonly<CounterpartyCounterpartiesUpdateBody>}, TContext> => {

const mutationKey = ['counterpartiesUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof counterpartiesUpdate>>, {counterpartyId: string;data: NonReadonly<CounterpartyCounterpartiesUpdateBody>}> = (props) => {
          const {counterpartyId,data} = props ?? {};

          return  counterpartiesUpdate(counterpartyId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CounterpartiesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof counterpartiesUpdate>>>
    export type CounterpartiesUpdateMutationBody = NonReadonly<CounterpartyCounterpartiesUpdateBody>
    export type CounterpartiesUpdateMutationError = GooglerpcStatus

    /**
 * @summary Update counterparty
 */
export const useCounterpartiesUpdate = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof counterpartiesUpdate>>, TError,{counterpartyId: string;data: NonReadonly<CounterpartyCounterpartiesUpdateBody>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof counterpartiesUpdate>>,
        TError,
        {counterpartyId: string;data: NonReadonly<CounterpartyCounterpartiesUpdateBody>},
        TContext
      > => {

      const mutationOptions = getCounterpartiesUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Create counterparty account
 */
export const counterpartiesCreateAccount = (
    counterpartyId: string,
    counterpartyCounterpartiesCreateAccountBody: CounterpartyCounterpartiesCreateAccountBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CounterpartyCounterpartyAccountResponseV2>(
      {url: `/v2/counterparty/${counterpartyId}/account`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: counterpartyCounterpartiesCreateAccountBody, signal
    },
      );
    }
  


export const getCounterpartiesCreateAccountMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof counterpartiesCreateAccount>>, TError,{counterpartyId: string;data: CounterpartyCounterpartiesCreateAccountBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof counterpartiesCreateAccount>>, TError,{counterpartyId: string;data: CounterpartyCounterpartiesCreateAccountBody}, TContext> => {

const mutationKey = ['counterpartiesCreateAccount'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof counterpartiesCreateAccount>>, {counterpartyId: string;data: CounterpartyCounterpartiesCreateAccountBody}> = (props) => {
          const {counterpartyId,data} = props ?? {};

          return  counterpartiesCreateAccount(counterpartyId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CounterpartiesCreateAccountMutationResult = NonNullable<Awaited<ReturnType<typeof counterpartiesCreateAccount>>>
    export type CounterpartiesCreateAccountMutationBody = CounterpartyCounterpartiesCreateAccountBody
    export type CounterpartiesCreateAccountMutationError = GooglerpcStatus

    /**
 * @summary Create counterparty account
 */
export const useCounterpartiesCreateAccount = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof counterpartiesCreateAccount>>, TError,{counterpartyId: string;data: CounterpartyCounterpartiesCreateAccountBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof counterpartiesCreateAccount>>,
        TError,
        {counterpartyId: string;data: CounterpartyCounterpartiesCreateAccountBody},
        TContext
      > => {

      const mutationOptions = getCounterpartiesCreateAccountMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Update counterparty account
 */
export const counterpartiesUpdateAccount = (
    counterpartyId: string,
    accountId: string,
    counterpartyCounterpartiesUpdateAccountBody: CounterpartyCounterpartiesUpdateAccountBody,
 ) => {
      
      
      return customInstance<CounterpartyCounterpartyAccountResponseV2>(
      {url: `/v2/counterparty/${counterpartyId}/account/${accountId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: counterpartyCounterpartiesUpdateAccountBody
    },
      );
    }
  


export const getCounterpartiesUpdateAccountMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof counterpartiesUpdateAccount>>, TError,{counterpartyId: string;accountId: string;data: CounterpartyCounterpartiesUpdateAccountBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof counterpartiesUpdateAccount>>, TError,{counterpartyId: string;accountId: string;data: CounterpartyCounterpartiesUpdateAccountBody}, TContext> => {

const mutationKey = ['counterpartiesUpdateAccount'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof counterpartiesUpdateAccount>>, {counterpartyId: string;accountId: string;data: CounterpartyCounterpartiesUpdateAccountBody}> = (props) => {
          const {counterpartyId,accountId,data} = props ?? {};

          return  counterpartiesUpdateAccount(counterpartyId,accountId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CounterpartiesUpdateAccountMutationResult = NonNullable<Awaited<ReturnType<typeof counterpartiesUpdateAccount>>>
    export type CounterpartiesUpdateAccountMutationBody = CounterpartyCounterpartiesUpdateAccountBody
    export type CounterpartiesUpdateAccountMutationError = GooglerpcStatus

    /**
 * @summary Update counterparty account
 */
export const useCounterpartiesUpdateAccount = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof counterpartiesUpdateAccount>>, TError,{counterpartyId: string;accountId: string;data: CounterpartyCounterpartiesUpdateAccountBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof counterpartiesUpdateAccount>>,
        TError,
        {counterpartyId: string;accountId: string;data: CounterpartyCounterpartiesUpdateAccountBody},
        TContext
      > => {

      const mutationOptions = getCounterpartiesUpdateAccountMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary List Currencies
 */
export const currencyList = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<CurrencyCurrencyList>(
      {url: `/v2/currency`, method: 'GET', signal
    },
      );
    }
  



export const getCurrencyListQueryKey = () => {
    return [
    `/v2/currency`
    ] as const;
    }

    
export const getCurrencyListQueryOptions = <TData = Awaited<ReturnType<typeof currencyList>>, TError = GooglerpcStatus>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof currencyList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCurrencyListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof currencyList>>> = ({ signal }) => currencyList(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof currencyList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CurrencyListQueryResult = NonNullable<Awaited<ReturnType<typeof currencyList>>>
export type CurrencyListQueryError = GooglerpcStatus


export function useCurrencyList<TData = Awaited<ReturnType<typeof currencyList>>, TError = GooglerpcStatus>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof currencyList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof currencyList>>,
          TError,
          Awaited<ReturnType<typeof currencyList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCurrencyList<TData = Awaited<ReturnType<typeof currencyList>>, TError = GooglerpcStatus>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof currencyList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof currencyList>>,
          TError,
          Awaited<ReturnType<typeof currencyList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCurrencyList<TData = Awaited<ReturnType<typeof currencyList>>, TError = GooglerpcStatus>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof currencyList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Currencies
 */

export function useCurrencyList<TData = Awaited<ReturnType<typeof currencyList>>, TError = GooglerpcStatus>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof currencyList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCurrencyListQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Convert
 */
export const currencyConvert = (
    currencyConvertRequest: CurrencyConvertRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CurrencyConvertResponse>(
      {url: `/v2/currency`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: currencyConvertRequest, signal
    },
      );
    }
  


export const getCurrencyConvertMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof currencyConvert>>, TError,{data: CurrencyConvertRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof currencyConvert>>, TError,{data: CurrencyConvertRequest}, TContext> => {

const mutationKey = ['currencyConvert'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof currencyConvert>>, {data: CurrencyConvertRequest}> = (props) => {
          const {data} = props ?? {};

          return  currencyConvert(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CurrencyConvertMutationResult = NonNullable<Awaited<ReturnType<typeof currencyConvert>>>
    export type CurrencyConvertMutationBody = CurrencyConvertRequest
    export type CurrencyConvertMutationError = GooglerpcStatus

    /**
 * @summary Convert
 */
export const useCurrencyConvert = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof currencyConvert>>, TError,{data: CurrencyConvertRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof currencyConvert>>,
        TError,
        {data: CurrencyConvertRequest},
        TContext
      > => {

      const mutationOptions = getCurrencyConvertMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get Currency
 */
export const currencyGet = (
    code: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CurrencyCurrencyModel>(
      {url: `/v2/currency/${code}`, method: 'GET', signal
    },
      );
    }
  



export const getCurrencyGetQueryKey = (code?: string,) => {
    return [
    `/v2/currency/${code}`
    ] as const;
    }

    
export const getCurrencyGetQueryOptions = <TData = Awaited<ReturnType<typeof currencyGet>>, TError = GooglerpcStatus>(code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof currencyGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCurrencyGetQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof currencyGet>>> = ({ signal }) => currencyGet(code, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof currencyGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CurrencyGetQueryResult = NonNullable<Awaited<ReturnType<typeof currencyGet>>>
export type CurrencyGetQueryError = GooglerpcStatus


export function useCurrencyGet<TData = Awaited<ReturnType<typeof currencyGet>>, TError = GooglerpcStatus>(
 code: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof currencyGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof currencyGet>>,
          TError,
          Awaited<ReturnType<typeof currencyGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCurrencyGet<TData = Awaited<ReturnType<typeof currencyGet>>, TError = GooglerpcStatus>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof currencyGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof currencyGet>>,
          TError,
          Awaited<ReturnType<typeof currencyGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCurrencyGet<TData = Awaited<ReturnType<typeof currencyGet>>, TError = GooglerpcStatus>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof currencyGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Currency
 */

export function useCurrencyGet<TData = Awaited<ReturnType<typeof currencyGet>>, TError = GooglerpcStatus>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof currencyGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCurrencyGetQueryOptions(code,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary List Customers
 */
export const customerList = (
    params?: CustomerListParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CustomerListCustomerRespond>(
      {url: `/v2/customer`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getCustomerListQueryKey = (params?: CustomerListParams,) => {
    return [
    `/v2/customer`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getCustomerListQueryOptions = <TData = Awaited<ReturnType<typeof customerList>>, TError = GooglerpcStatus>(params?: CustomerListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customerList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCustomerListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof customerList>>> = ({ signal }) => customerList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof customerList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CustomerListQueryResult = NonNullable<Awaited<ReturnType<typeof customerList>>>
export type CustomerListQueryError = GooglerpcStatus


export function useCustomerList<TData = Awaited<ReturnType<typeof customerList>>, TError = GooglerpcStatus>(
 params: undefined |  CustomerListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof customerList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof customerList>>,
          TError,
          Awaited<ReturnType<typeof customerList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCustomerList<TData = Awaited<ReturnType<typeof customerList>>, TError = GooglerpcStatus>(
 params?: CustomerListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customerList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof customerList>>,
          TError,
          Awaited<ReturnType<typeof customerList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCustomerList<TData = Awaited<ReturnType<typeof customerList>>, TError = GooglerpcStatus>(
 params?: CustomerListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customerList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Customers
 */

export function useCustomerList<TData = Awaited<ReturnType<typeof customerList>>, TError = GooglerpcStatus>(
 params?: CustomerListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customerList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCustomerListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Add Customer
 */
export const customerAdd = (
    customerCreateCustomerRequest: CustomerCreateCustomerRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CustomerCustomerRespond>(
      {url: `/v2/customer`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: customerCreateCustomerRequest, signal
    },
      );
    }
  


export const getCustomerAddMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof customerAdd>>, TError,{data: CustomerCreateCustomerRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof customerAdd>>, TError,{data: CustomerCreateCustomerRequest}, TContext> => {

const mutationKey = ['customerAdd'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof customerAdd>>, {data: CustomerCreateCustomerRequest}> = (props) => {
          const {data} = props ?? {};

          return  customerAdd(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CustomerAddMutationResult = NonNullable<Awaited<ReturnType<typeof customerAdd>>>
    export type CustomerAddMutationBody = CustomerCreateCustomerRequest
    export type CustomerAddMutationError = GooglerpcStatus

    /**
 * @summary Add Customer
 */
export const useCustomerAdd = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof customerAdd>>, TError,{data: CustomerCreateCustomerRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof customerAdd>>,
        TError,
        {data: CustomerCreateCustomerRequest},
        TContext
      > => {

      const mutationOptions = getCustomerAddMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Upload document request.<br> Use POST ```multipart/form-data``` content type for send this form
 * @summary Upload Document
 */
export const customerUploadFileDummy = (
    customerDocumentUpload: CustomerDocumentUpload,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CustomerDocumentRespond>(
      {url: `/v2/customer/file`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: customerDocumentUpload, signal
    },
      );
    }
  


export const getCustomerUploadFileDummyMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof customerUploadFileDummy>>, TError,{data: CustomerDocumentUpload}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof customerUploadFileDummy>>, TError,{data: CustomerDocumentUpload}, TContext> => {

const mutationKey = ['customerUploadFileDummy'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof customerUploadFileDummy>>, {data: CustomerDocumentUpload}> = (props) => {
          const {data} = props ?? {};

          return  customerUploadFileDummy(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CustomerUploadFileDummyMutationResult = NonNullable<Awaited<ReturnType<typeof customerUploadFileDummy>>>
    export type CustomerUploadFileDummyMutationBody = CustomerDocumentUpload
    export type CustomerUploadFileDummyMutationError = GooglerpcStatus

    /**
 * @summary Upload Document
 */
export const useCustomerUploadFileDummy = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof customerUploadFileDummy>>, TError,{data: CustomerDocumentUpload}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof customerUploadFileDummy>>,
        TError,
        {data: CustomerDocumentUpload},
        TContext
      > => {

      const mutationOptions = getCustomerUploadFileDummyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get Customer
 */
export const customerGet = (
    customerId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CustomerCustomerRespondDetail>(
      {url: `/v2/customer/${customerId}`, method: 'GET', signal
    },
      );
    }
  



export const getCustomerGetQueryKey = (customerId?: string,) => {
    return [
    `/v2/customer/${customerId}`
    ] as const;
    }

    
export const getCustomerGetQueryOptions = <TData = Awaited<ReturnType<typeof customerGet>>, TError = GooglerpcStatus>(customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customerGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCustomerGetQueryKey(customerId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof customerGet>>> = ({ signal }) => customerGet(customerId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(customerId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof customerGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CustomerGetQueryResult = NonNullable<Awaited<ReturnType<typeof customerGet>>>
export type CustomerGetQueryError = GooglerpcStatus


export function useCustomerGet<TData = Awaited<ReturnType<typeof customerGet>>, TError = GooglerpcStatus>(
 customerId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof customerGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof customerGet>>,
          TError,
          Awaited<ReturnType<typeof customerGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCustomerGet<TData = Awaited<ReturnType<typeof customerGet>>, TError = GooglerpcStatus>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customerGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof customerGet>>,
          TError,
          Awaited<ReturnType<typeof customerGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCustomerGet<TData = Awaited<ReturnType<typeof customerGet>>, TError = GooglerpcStatus>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customerGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Customer
 */

export function useCustomerGet<TData = Awaited<ReturnType<typeof customerGet>>, TError = GooglerpcStatus>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customerGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCustomerGetQueryOptions(customerId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update Customer
 */
export const customerUpdate = (
    customerId: string,
    customerCustomerUpdateBody: CustomerCustomerUpdateBody,
 ) => {
      
      
      return customInstance<CustomerCustomerRespond>(
      {url: `/v2/customer/${customerId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: customerCustomerUpdateBody
    },
      );
    }
  


export const getCustomerUpdateMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof customerUpdate>>, TError,{customerId: string;data: CustomerCustomerUpdateBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof customerUpdate>>, TError,{customerId: string;data: CustomerCustomerUpdateBody}, TContext> => {

const mutationKey = ['customerUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof customerUpdate>>, {customerId: string;data: CustomerCustomerUpdateBody}> = (props) => {
          const {customerId,data} = props ?? {};

          return  customerUpdate(customerId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CustomerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof customerUpdate>>>
    export type CustomerUpdateMutationBody = CustomerCustomerUpdateBody
    export type CustomerUpdateMutationError = GooglerpcStatus

    /**
 * @summary Update Customer
 */
export const useCustomerUpdate = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof customerUpdate>>, TError,{customerId: string;data: CustomerCustomerUpdateBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof customerUpdate>>,
        TError,
        {customerId: string;data: CustomerCustomerUpdateBody},
        TContext
      > => {

      const mutationOptions = getCustomerUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get Customer Application.<br>Return ```individual``` or ```corporate``` Application.
 * @summary Get Customer Application
 */
export const customerGetApplication = (
    customerId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CustomerGetApplicationRespond>(
      {url: `/v2/customer/${customerId}/application`, method: 'GET', signal
    },
      );
    }
  



export const getCustomerGetApplicationQueryKey = (customerId?: string,) => {
    return [
    `/v2/customer/${customerId}/application`
    ] as const;
    }

    
export const getCustomerGetApplicationQueryOptions = <TData = Awaited<ReturnType<typeof customerGetApplication>>, TError = GooglerpcStatus>(customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customerGetApplication>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCustomerGetApplicationQueryKey(customerId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof customerGetApplication>>> = ({ signal }) => customerGetApplication(customerId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(customerId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof customerGetApplication>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CustomerGetApplicationQueryResult = NonNullable<Awaited<ReturnType<typeof customerGetApplication>>>
export type CustomerGetApplicationQueryError = GooglerpcStatus


export function useCustomerGetApplication<TData = Awaited<ReturnType<typeof customerGetApplication>>, TError = GooglerpcStatus>(
 customerId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof customerGetApplication>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof customerGetApplication>>,
          TError,
          Awaited<ReturnType<typeof customerGetApplication>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCustomerGetApplication<TData = Awaited<ReturnType<typeof customerGetApplication>>, TError = GooglerpcStatus>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customerGetApplication>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof customerGetApplication>>,
          TError,
          Awaited<ReturnType<typeof customerGetApplication>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCustomerGetApplication<TData = Awaited<ReturnType<typeof customerGetApplication>>, TError = GooglerpcStatus>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customerGetApplication>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Customer Application
 */

export function useCustomerGetApplication<TData = Awaited<ReturnType<typeof customerGetApplication>>, TError = GooglerpcStatus>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customerGetApplication>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCustomerGetApplicationQueryOptions(customerId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Setup Customer Application.<br>Set oneof parameter ```individual``` or ```corporate```, not both
 * @summary Set Customer Application
 */
export const customerSetApplication = (
    customerId: string,
    customerSetApplicationBody: CustomerSetApplicationBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CustomerSetApplicationRespond>(
      {url: `/v2/customer/${customerId}/application`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: customerSetApplicationBody, signal
    },
      );
    }
  


export const getCustomerSetApplicationMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof customerSetApplication>>, TError,{customerId: string;data: CustomerSetApplicationBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof customerSetApplication>>, TError,{customerId: string;data: CustomerSetApplicationBody}, TContext> => {

const mutationKey = ['customerSetApplication'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof customerSetApplication>>, {customerId: string;data: CustomerSetApplicationBody}> = (props) => {
          const {customerId,data} = props ?? {};

          return  customerSetApplication(customerId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CustomerSetApplicationMutationResult = NonNullable<Awaited<ReturnType<typeof customerSetApplication>>>
    export type CustomerSetApplicationMutationBody = CustomerSetApplicationBody
    export type CustomerSetApplicationMutationError = GooglerpcStatus

    /**
 * @summary Set Customer Application
 */
export const useCustomerSetApplication = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof customerSetApplication>>, TError,{customerId: string;data: CustomerSetApplicationBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof customerSetApplication>>,
        TError,
        {customerId: string;data: CustomerSetApplicationBody},
        TContext
      > => {

      const mutationOptions = getCustomerSetApplicationMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary List Documents
 */
export const customerListDocuments = (
    customerId: string,
    params?: CustomerListDocumentsParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<V2customerDocumentListRespond>(
      {url: `/v2/customer/${customerId}/file`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getCustomerListDocumentsQueryKey = (customerId?: string,
    params?: CustomerListDocumentsParams,) => {
    return [
    `/v2/customer/${customerId}/file`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getCustomerListDocumentsQueryOptions = <TData = Awaited<ReturnType<typeof customerListDocuments>>, TError = GooglerpcStatus>(customerId: string,
    params?: CustomerListDocumentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customerListDocuments>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCustomerListDocumentsQueryKey(customerId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof customerListDocuments>>> = ({ signal }) => customerListDocuments(customerId,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(customerId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof customerListDocuments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CustomerListDocumentsQueryResult = NonNullable<Awaited<ReturnType<typeof customerListDocuments>>>
export type CustomerListDocumentsQueryError = GooglerpcStatus


export function useCustomerListDocuments<TData = Awaited<ReturnType<typeof customerListDocuments>>, TError = GooglerpcStatus>(
 customerId: string,
    params: undefined |  CustomerListDocumentsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof customerListDocuments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof customerListDocuments>>,
          TError,
          Awaited<ReturnType<typeof customerListDocuments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCustomerListDocuments<TData = Awaited<ReturnType<typeof customerListDocuments>>, TError = GooglerpcStatus>(
 customerId: string,
    params?: CustomerListDocumentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customerListDocuments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof customerListDocuments>>,
          TError,
          Awaited<ReturnType<typeof customerListDocuments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCustomerListDocuments<TData = Awaited<ReturnType<typeof customerListDocuments>>, TError = GooglerpcStatus>(
 customerId: string,
    params?: CustomerListDocumentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customerListDocuments>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Documents
 */

export function useCustomerListDocuments<TData = Awaited<ReturnType<typeof customerListDocuments>>, TError = GooglerpcStatus>(
 customerId: string,
    params?: CustomerListDocumentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customerListDocuments>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCustomerListDocumentsQueryOptions(customerId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Download document.<br> Return raw file content with mimetype header of document
 * @summary Download Document
 */
export const customerDocumentDownload = (
    customerId: string,
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ApiHttpBody>(
      {url: `/v2/customer/${customerId}/file/${id}`, method: 'GET', signal
    },
      );
    }
  



export const getCustomerDocumentDownloadQueryKey = (customerId?: string,
    id?: string,) => {
    return [
    `/v2/customer/${customerId}/file/${id}`
    ] as const;
    }

    
export const getCustomerDocumentDownloadQueryOptions = <TData = Awaited<ReturnType<typeof customerDocumentDownload>>, TError = GooglerpcStatus>(customerId: string,
    id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customerDocumentDownload>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCustomerDocumentDownloadQueryKey(customerId,id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof customerDocumentDownload>>> = ({ signal }) => customerDocumentDownload(customerId,id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(customerId && id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof customerDocumentDownload>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CustomerDocumentDownloadQueryResult = NonNullable<Awaited<ReturnType<typeof customerDocumentDownload>>>
export type CustomerDocumentDownloadQueryError = GooglerpcStatus


export function useCustomerDocumentDownload<TData = Awaited<ReturnType<typeof customerDocumentDownload>>, TError = GooglerpcStatus>(
 customerId: string,
    id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof customerDocumentDownload>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof customerDocumentDownload>>,
          TError,
          Awaited<ReturnType<typeof customerDocumentDownload>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCustomerDocumentDownload<TData = Awaited<ReturnType<typeof customerDocumentDownload>>, TError = GooglerpcStatus>(
 customerId: string,
    id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customerDocumentDownload>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof customerDocumentDownload>>,
          TError,
          Awaited<ReturnType<typeof customerDocumentDownload>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCustomerDocumentDownload<TData = Awaited<ReturnType<typeof customerDocumentDownload>>, TError = GooglerpcStatus>(
 customerId: string,
    id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customerDocumentDownload>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Download Document
 */

export function useCustomerDocumentDownload<TData = Awaited<ReturnType<typeof customerDocumentDownload>>, TError = GooglerpcStatus>(
 customerId: string,
    id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customerDocumentDownload>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCustomerDocumentDownloadQueryOptions(customerId,id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Remove document.
 * @summary Delete Document
 */
export const customerDocumentDelete = (
    customerId: string,
    id: string,
 ) => {
      
      
      return customInstance<V2RespondStatus>(
      {url: `/v2/customer/${customerId}/file/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getCustomerDocumentDeleteMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof customerDocumentDelete>>, TError,{customerId: string;id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof customerDocumentDelete>>, TError,{customerId: string;id: string}, TContext> => {

const mutationKey = ['customerDocumentDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof customerDocumentDelete>>, {customerId: string;id: string}> = (props) => {
          const {customerId,id} = props ?? {};

          return  customerDocumentDelete(customerId,id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CustomerDocumentDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof customerDocumentDelete>>>
    
    export type CustomerDocumentDeleteMutationError = GooglerpcStatus

    /**
 * @summary Delete Document
 */
export const useCustomerDocumentDelete = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof customerDocumentDelete>>, TError,{customerId: string;id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof customerDocumentDelete>>,
        TError,
        {customerId: string;id: string},
        TContext
      > => {

      const mutationOptions = getCustomerDocumentDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Update document.
 * @summary Document update
 */
export const customerDocumentUpdate = (
    customerId: string,
    id: string,
    customerDocumentUpdateBody: CustomerDocumentUpdateBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CustomerDocumentRespond>(
      {url: `/v2/customer/${customerId}/file/${id}`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: customerDocumentUpdateBody, signal
    },
      );
    }
  


export const getCustomerDocumentUpdateMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof customerDocumentUpdate>>, TError,{customerId: string;id: string;data: CustomerDocumentUpdateBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof customerDocumentUpdate>>, TError,{customerId: string;id: string;data: CustomerDocumentUpdateBody}, TContext> => {

const mutationKey = ['customerDocumentUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof customerDocumentUpdate>>, {customerId: string;id: string;data: CustomerDocumentUpdateBody}> = (props) => {
          const {customerId,id,data} = props ?? {};

          return  customerDocumentUpdate(customerId,id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CustomerDocumentUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof customerDocumentUpdate>>>
    export type CustomerDocumentUpdateMutationBody = CustomerDocumentUpdateBody
    export type CustomerDocumentUpdateMutationError = GooglerpcStatus

    /**
 * @summary Document update
 */
export const useCustomerDocumentUpdate = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof customerDocumentUpdate>>, TError,{customerId: string;id: string;data: CustomerDocumentUpdateBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof customerDocumentUpdate>>,
        TError,
        {customerId: string;id: string;data: CustomerDocumentUpdateBody},
        TContext
      > => {

      const mutationOptions = getCustomerDocumentUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get document info.
 * @summary Get Document Information
 */
export const customerGetDocumentInfo = (
    customerId: string,
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CustomerDocumentRespond>(
      {url: `/v2/customer/${customerId}/file/${id}/info`, method: 'GET', signal
    },
      );
    }
  



export const getCustomerGetDocumentInfoQueryKey = (customerId?: string,
    id?: string,) => {
    return [
    `/v2/customer/${customerId}/file/${id}/info`
    ] as const;
    }

    
export const getCustomerGetDocumentInfoQueryOptions = <TData = Awaited<ReturnType<typeof customerGetDocumentInfo>>, TError = GooglerpcStatus>(customerId: string,
    id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customerGetDocumentInfo>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCustomerGetDocumentInfoQueryKey(customerId,id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof customerGetDocumentInfo>>> = ({ signal }) => customerGetDocumentInfo(customerId,id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(customerId && id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof customerGetDocumentInfo>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CustomerGetDocumentInfoQueryResult = NonNullable<Awaited<ReturnType<typeof customerGetDocumentInfo>>>
export type CustomerGetDocumentInfoQueryError = GooglerpcStatus


export function useCustomerGetDocumentInfo<TData = Awaited<ReturnType<typeof customerGetDocumentInfo>>, TError = GooglerpcStatus>(
 customerId: string,
    id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof customerGetDocumentInfo>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof customerGetDocumentInfo>>,
          TError,
          Awaited<ReturnType<typeof customerGetDocumentInfo>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCustomerGetDocumentInfo<TData = Awaited<ReturnType<typeof customerGetDocumentInfo>>, TError = GooglerpcStatus>(
 customerId: string,
    id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customerGetDocumentInfo>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof customerGetDocumentInfo>>,
          TError,
          Awaited<ReturnType<typeof customerGetDocumentInfo>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCustomerGetDocumentInfo<TData = Awaited<ReturnType<typeof customerGetDocumentInfo>>, TError = GooglerpcStatus>(
 customerId: string,
    id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customerGetDocumentInfo>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Document Information
 */

export function useCustomerGetDocumentInfo<TData = Awaited<ReturnType<typeof customerGetDocumentInfo>>, TError = GooglerpcStatus>(
 customerId: string,
    id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customerGetDocumentInfo>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCustomerGetDocumentInfoQueryOptions(customerId,id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Country List
 */
export const geoList = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<V1CountryList>(
      {url: `/v2/geo/country/get`, method: 'GET', signal
    },
      );
    }
  



export const getGeoListQueryKey = () => {
    return [
    `/v2/geo/country/get`
    ] as const;
    }

    
export const getGeoListQueryOptions = <TData = Awaited<ReturnType<typeof geoList>>, TError = GooglerpcStatus>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof geoList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGeoListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof geoList>>> = ({ signal }) => geoList(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof geoList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GeoListQueryResult = NonNullable<Awaited<ReturnType<typeof geoList>>>
export type GeoListQueryError = GooglerpcStatus


export function useGeoList<TData = Awaited<ReturnType<typeof geoList>>, TError = GooglerpcStatus>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof geoList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof geoList>>,
          TError,
          Awaited<ReturnType<typeof geoList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGeoList<TData = Awaited<ReturnType<typeof geoList>>, TError = GooglerpcStatus>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof geoList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof geoList>>,
          TError,
          Awaited<ReturnType<typeof geoList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGeoList<TData = Awaited<ReturnType<typeof geoList>>, TError = GooglerpcStatus>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof geoList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Country List
 */

export function useGeoList<TData = Awaited<ReturnType<typeof geoList>>, TError = GooglerpcStatus>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof geoList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGeoListQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary States List
 */
export const geoStatesList = (
    params?: GeoStatesListParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<GeoStates>(
      {url: `/v2/geo/state`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGeoStatesListQueryKey = (params?: GeoStatesListParams,) => {
    return [
    `/v2/geo/state`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGeoStatesListQueryOptions = <TData = Awaited<ReturnType<typeof geoStatesList>>, TError = GooglerpcStatus>(params?: GeoStatesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof geoStatesList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGeoStatesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof geoStatesList>>> = ({ signal }) => geoStatesList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof geoStatesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GeoStatesListQueryResult = NonNullable<Awaited<ReturnType<typeof geoStatesList>>>
export type GeoStatesListQueryError = GooglerpcStatus


export function useGeoStatesList<TData = Awaited<ReturnType<typeof geoStatesList>>, TError = GooglerpcStatus>(
 params: undefined |  GeoStatesListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof geoStatesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof geoStatesList>>,
          TError,
          Awaited<ReturnType<typeof geoStatesList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGeoStatesList<TData = Awaited<ReturnType<typeof geoStatesList>>, TError = GooglerpcStatus>(
 params?: GeoStatesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof geoStatesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof geoStatesList>>,
          TError,
          Awaited<ReturnType<typeof geoStatesList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGeoStatesList<TData = Awaited<ReturnType<typeof geoStatesList>>, TError = GooglerpcStatus>(
 params?: GeoStatesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof geoStatesList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary States List
 */

export function useGeoStatesList<TData = Awaited<ReturnType<typeof geoStatesList>>, TError = GooglerpcStatus>(
 params?: GeoStatesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof geoStatesList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGeoStatesListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get Hook Parameters
 */
export const hookGetParameters = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<Hooksv1PartnerParameters>(
      {url: `/v2/hook/get`, method: 'GET', signal
    },
      );
    }
  



export const getHookGetParametersQueryKey = () => {
    return [
    `/v2/hook/get`
    ] as const;
    }

    
export const getHookGetParametersQueryOptions = <TData = Awaited<ReturnType<typeof hookGetParameters>>, TError = GooglerpcStatus>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof hookGetParameters>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHookGetParametersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof hookGetParameters>>> = ({ signal }) => hookGetParameters(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof hookGetParameters>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HookGetParametersQueryResult = NonNullable<Awaited<ReturnType<typeof hookGetParameters>>>
export type HookGetParametersQueryError = GooglerpcStatus


export function useHookGetParameters<TData = Awaited<ReturnType<typeof hookGetParameters>>, TError = GooglerpcStatus>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof hookGetParameters>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof hookGetParameters>>,
          TError,
          Awaited<ReturnType<typeof hookGetParameters>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHookGetParameters<TData = Awaited<ReturnType<typeof hookGetParameters>>, TError = GooglerpcStatus>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof hookGetParameters>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof hookGetParameters>>,
          TError,
          Awaited<ReturnType<typeof hookGetParameters>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHookGetParameters<TData = Awaited<ReturnType<typeof hookGetParameters>>, TError = GooglerpcStatus>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof hookGetParameters>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Hook Parameters
 */

export function useHookGetParameters<TData = Awaited<ReturnType<typeof hookGetParameters>>, TError = GooglerpcStatus>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof hookGetParameters>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getHookGetParametersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Set Hook Parameters
 */
export const hookSetParameters = (
    v2hookPartnerUpdateRequest: V2hookPartnerUpdateRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<Hooksv1PartnerParameters>(
      {url: `/v2/hook/set`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: v2hookPartnerUpdateRequest, signal
    },
      );
    }
  


export const getHookSetParametersMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof hookSetParameters>>, TError,{data: V2hookPartnerUpdateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof hookSetParameters>>, TError,{data: V2hookPartnerUpdateRequest}, TContext> => {

const mutationKey = ['hookSetParameters'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof hookSetParameters>>, {data: V2hookPartnerUpdateRequest}> = (props) => {
          const {data} = props ?? {};

          return  hookSetParameters(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type HookSetParametersMutationResult = NonNullable<Awaited<ReturnType<typeof hookSetParameters>>>
    export type HookSetParametersMutationBody = V2hookPartnerUpdateRequest
    export type HookSetParametersMutationError = GooglerpcStatus

    /**
 * @summary Set Hook Parameters
 */
export const useHookSetParameters = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof hookSetParameters>>, TError,{data: V2hookPartnerUpdateRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof hookSetParameters>>,
        TError,
        {data: V2hookPartnerUpdateRequest},
        TContext
      > => {

      const mutationOptions = getHookSetParametersMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Event list
 */
export const messagesGetEvents = (
    params?: MessagesGetEventsParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<V2messageEventsResponse>(
      {url: `/v2/messages/events`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getMessagesGetEventsQueryKey = (params?: MessagesGetEventsParams,) => {
    return [
    `/v2/messages/events`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getMessagesGetEventsQueryOptions = <TData = Awaited<ReturnType<typeof messagesGetEvents>>, TError = GooglerpcStatus>(params?: MessagesGetEventsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof messagesGetEvents>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMessagesGetEventsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof messagesGetEvents>>> = ({ signal }) => messagesGetEvents(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof messagesGetEvents>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type MessagesGetEventsQueryResult = NonNullable<Awaited<ReturnType<typeof messagesGetEvents>>>
export type MessagesGetEventsQueryError = GooglerpcStatus


export function useMessagesGetEvents<TData = Awaited<ReturnType<typeof messagesGetEvents>>, TError = GooglerpcStatus>(
 params: undefined |  MessagesGetEventsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof messagesGetEvents>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof messagesGetEvents>>,
          TError,
          Awaited<ReturnType<typeof messagesGetEvents>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMessagesGetEvents<TData = Awaited<ReturnType<typeof messagesGetEvents>>, TError = GooglerpcStatus>(
 params?: MessagesGetEventsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof messagesGetEvents>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof messagesGetEvents>>,
          TError,
          Awaited<ReturnType<typeof messagesGetEvents>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMessagesGetEvents<TData = Awaited<ReturnType<typeof messagesGetEvents>>, TError = GooglerpcStatus>(
 params?: MessagesGetEventsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof messagesGetEvents>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Event list
 */

export function useMessagesGetEvents<TData = Awaited<ReturnType<typeof messagesGetEvents>>, TError = GooglerpcStatus>(
 params?: MessagesGetEventsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof messagesGetEvents>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMessagesGetEventsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get Settings
 */
export const messagesGetSettings = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<MessageSettingResponse>(
      {url: `/v2/messages/settings`, method: 'GET', signal
    },
      );
    }
  



export const getMessagesGetSettingsQueryKey = () => {
    return [
    `/v2/messages/settings`
    ] as const;
    }

    
export const getMessagesGetSettingsQueryOptions = <TData = Awaited<ReturnType<typeof messagesGetSettings>>, TError = GooglerpcStatus>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof messagesGetSettings>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMessagesGetSettingsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof messagesGetSettings>>> = ({ signal }) => messagesGetSettings(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof messagesGetSettings>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type MessagesGetSettingsQueryResult = NonNullable<Awaited<ReturnType<typeof messagesGetSettings>>>
export type MessagesGetSettingsQueryError = GooglerpcStatus


export function useMessagesGetSettings<TData = Awaited<ReturnType<typeof messagesGetSettings>>, TError = GooglerpcStatus>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof messagesGetSettings>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof messagesGetSettings>>,
          TError,
          Awaited<ReturnType<typeof messagesGetSettings>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMessagesGetSettings<TData = Awaited<ReturnType<typeof messagesGetSettings>>, TError = GooglerpcStatus>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof messagesGetSettings>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof messagesGetSettings>>,
          TError,
          Awaited<ReturnType<typeof messagesGetSettings>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMessagesGetSettings<TData = Awaited<ReturnType<typeof messagesGetSettings>>, TError = GooglerpcStatus>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof messagesGetSettings>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Settings
 */

export function useMessagesGetSettings<TData = Awaited<ReturnType<typeof messagesGetSettings>>, TError = GooglerpcStatus>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof messagesGetSettings>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMessagesGetSettingsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update Settings
 */
export const messagesUpdateSettings = (
    messageSettingUpdateRequest: MessageSettingUpdateRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<MessageSettingResponse>(
      {url: `/v2/messages/settings`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: messageSettingUpdateRequest, signal
    },
      );
    }
  


export const getMessagesUpdateSettingsMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof messagesUpdateSettings>>, TError,{data: MessageSettingUpdateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof messagesUpdateSettings>>, TError,{data: MessageSettingUpdateRequest}, TContext> => {

const mutationKey = ['messagesUpdateSettings'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof messagesUpdateSettings>>, {data: MessageSettingUpdateRequest}> = (props) => {
          const {data} = props ?? {};

          return  messagesUpdateSettings(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type MessagesUpdateSettingsMutationResult = NonNullable<Awaited<ReturnType<typeof messagesUpdateSettings>>>
    export type MessagesUpdateSettingsMutationBody = MessageSettingUpdateRequest
    export type MessagesUpdateSettingsMutationError = GooglerpcStatus

    /**
 * @summary Update Settings
 */
export const useMessagesUpdateSettings = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof messagesUpdateSettings>>, TError,{data: MessageSettingUpdateRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof messagesUpdateSettings>>,
        TError,
        {data: MessageSettingUpdateRequest},
        TContext
      > => {

      const mutationOptions = getMessagesUpdateSettingsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get templates list
 */
export const messagesGetTemplates = (
    params?: MessagesGetTemplatesParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<MessageGetTemplatesResponse>(
      {url: `/v2/messages/templates`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getMessagesGetTemplatesQueryKey = (params?: MessagesGetTemplatesParams,) => {
    return [
    `/v2/messages/templates`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getMessagesGetTemplatesQueryOptions = <TData = Awaited<ReturnType<typeof messagesGetTemplates>>, TError = GooglerpcStatus>(params?: MessagesGetTemplatesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof messagesGetTemplates>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMessagesGetTemplatesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof messagesGetTemplates>>> = ({ signal }) => messagesGetTemplates(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof messagesGetTemplates>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type MessagesGetTemplatesQueryResult = NonNullable<Awaited<ReturnType<typeof messagesGetTemplates>>>
export type MessagesGetTemplatesQueryError = GooglerpcStatus


export function useMessagesGetTemplates<TData = Awaited<ReturnType<typeof messagesGetTemplates>>, TError = GooglerpcStatus>(
 params: undefined |  MessagesGetTemplatesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof messagesGetTemplates>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof messagesGetTemplates>>,
          TError,
          Awaited<ReturnType<typeof messagesGetTemplates>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMessagesGetTemplates<TData = Awaited<ReturnType<typeof messagesGetTemplates>>, TError = GooglerpcStatus>(
 params?: MessagesGetTemplatesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof messagesGetTemplates>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof messagesGetTemplates>>,
          TError,
          Awaited<ReturnType<typeof messagesGetTemplates>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMessagesGetTemplates<TData = Awaited<ReturnType<typeof messagesGetTemplates>>, TError = GooglerpcStatus>(
 params?: MessagesGetTemplatesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof messagesGetTemplates>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get templates list
 */

export function useMessagesGetTemplates<TData = Awaited<ReturnType<typeof messagesGetTemplates>>, TError = GooglerpcStatus>(
 params?: MessagesGetTemplatesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof messagesGetTemplates>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMessagesGetTemplatesQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create template account
 */
export const messagesCreateTemplate = (
    messageCreateTemplateRequest: MessageCreateTemplateRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<MessageGetTemplateResponse>(
      {url: `/v2/messages/templates`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: messageCreateTemplateRequest, signal
    },
      );
    }
  


export const getMessagesCreateTemplateMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof messagesCreateTemplate>>, TError,{data: MessageCreateTemplateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof messagesCreateTemplate>>, TError,{data: MessageCreateTemplateRequest}, TContext> => {

const mutationKey = ['messagesCreateTemplate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof messagesCreateTemplate>>, {data: MessageCreateTemplateRequest}> = (props) => {
          const {data} = props ?? {};

          return  messagesCreateTemplate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type MessagesCreateTemplateMutationResult = NonNullable<Awaited<ReturnType<typeof messagesCreateTemplate>>>
    export type MessagesCreateTemplateMutationBody = MessageCreateTemplateRequest
    export type MessagesCreateTemplateMutationError = GooglerpcStatus

    /**
 * @summary Create template account
 */
export const useMessagesCreateTemplate = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof messagesCreateTemplate>>, TError,{data: MessageCreateTemplateRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof messagesCreateTemplate>>,
        TError,
        {data: MessageCreateTemplateRequest},
        TContext
      > => {

      const mutationOptions = getMessagesCreateTemplateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get template by ID
 */
export const messagesGetTemplate = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<MessageGetTemplateResponse>(
      {url: `/v2/messages/templates/${id}`, method: 'GET', signal
    },
      );
    }
  



export const getMessagesGetTemplateQueryKey = (id?: string,) => {
    return [
    `/v2/messages/templates/${id}`
    ] as const;
    }

    
export const getMessagesGetTemplateQueryOptions = <TData = Awaited<ReturnType<typeof messagesGetTemplate>>, TError = GooglerpcStatus>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof messagesGetTemplate>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMessagesGetTemplateQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof messagesGetTemplate>>> = ({ signal }) => messagesGetTemplate(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof messagesGetTemplate>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type MessagesGetTemplateQueryResult = NonNullable<Awaited<ReturnType<typeof messagesGetTemplate>>>
export type MessagesGetTemplateQueryError = GooglerpcStatus


export function useMessagesGetTemplate<TData = Awaited<ReturnType<typeof messagesGetTemplate>>, TError = GooglerpcStatus>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof messagesGetTemplate>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof messagesGetTemplate>>,
          TError,
          Awaited<ReturnType<typeof messagesGetTemplate>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMessagesGetTemplate<TData = Awaited<ReturnType<typeof messagesGetTemplate>>, TError = GooglerpcStatus>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof messagesGetTemplate>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof messagesGetTemplate>>,
          TError,
          Awaited<ReturnType<typeof messagesGetTemplate>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMessagesGetTemplate<TData = Awaited<ReturnType<typeof messagesGetTemplate>>, TError = GooglerpcStatus>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof messagesGetTemplate>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get template by ID
 */

export function useMessagesGetTemplate<TData = Awaited<ReturnType<typeof messagesGetTemplate>>, TError = GooglerpcStatus>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof messagesGetTemplate>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMessagesGetTemplateQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Delete template by ID
 */
export const messagesDeleteTemplate = (
    id: string,
 ) => {
      
      
      return customInstance<Messagesv1SuccessResponse>(
      {url: `/v2/messages/templates/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getMessagesDeleteTemplateMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof messagesDeleteTemplate>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof messagesDeleteTemplate>>, TError,{id: string}, TContext> => {

const mutationKey = ['messagesDeleteTemplate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof messagesDeleteTemplate>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  messagesDeleteTemplate(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type MessagesDeleteTemplateMutationResult = NonNullable<Awaited<ReturnType<typeof messagesDeleteTemplate>>>
    
    export type MessagesDeleteTemplateMutationError = GooglerpcStatus

    /**
 * @summary Delete template by ID
 */
export const useMessagesDeleteTemplate = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof messagesDeleteTemplate>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof messagesDeleteTemplate>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getMessagesDeleteTemplateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Update template account
 */
export const messagesUpdateTemplate = (
    id: string,
    messagesUpdateTemplateBody: MessagesUpdateTemplateBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<MessageGetTemplateResponse>(
      {url: `/v2/messages/templates/${id}`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: messagesUpdateTemplateBody, signal
    },
      );
    }
  


export const getMessagesUpdateTemplateMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof messagesUpdateTemplate>>, TError,{id: string;data: MessagesUpdateTemplateBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof messagesUpdateTemplate>>, TError,{id: string;data: MessagesUpdateTemplateBody}, TContext> => {

const mutationKey = ['messagesUpdateTemplate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof messagesUpdateTemplate>>, {id: string;data: MessagesUpdateTemplateBody}> = (props) => {
          const {id,data} = props ?? {};

          return  messagesUpdateTemplate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type MessagesUpdateTemplateMutationResult = NonNullable<Awaited<ReturnType<typeof messagesUpdateTemplate>>>
    export type MessagesUpdateTemplateMutationBody = MessagesUpdateTemplateBody
    export type MessagesUpdateTemplateMutationError = GooglerpcStatus

    /**
 * @summary Update template account
 */
export const useMessagesUpdateTemplate = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof messagesUpdateTemplate>>, TError,{id: string;data: MessagesUpdateTemplateBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof messagesUpdateTemplate>>,
        TError,
        {id: string;data: MessagesUpdateTemplateBody},
        TContext
      > => {

      const mutationOptions = getMessagesUpdateTemplateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Type list
 */
export const messagesGetNotificationTypes = (
    params?: MessagesGetNotificationTypesParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<V2messageNotificationTypesResponse>(
      {url: `/v2/messages/types`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getMessagesGetNotificationTypesQueryKey = (params?: MessagesGetNotificationTypesParams,) => {
    return [
    `/v2/messages/types`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getMessagesGetNotificationTypesQueryOptions = <TData = Awaited<ReturnType<typeof messagesGetNotificationTypes>>, TError = GooglerpcStatus>(params?: MessagesGetNotificationTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof messagesGetNotificationTypes>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMessagesGetNotificationTypesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof messagesGetNotificationTypes>>> = ({ signal }) => messagesGetNotificationTypes(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof messagesGetNotificationTypes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type MessagesGetNotificationTypesQueryResult = NonNullable<Awaited<ReturnType<typeof messagesGetNotificationTypes>>>
export type MessagesGetNotificationTypesQueryError = GooglerpcStatus


export function useMessagesGetNotificationTypes<TData = Awaited<ReturnType<typeof messagesGetNotificationTypes>>, TError = GooglerpcStatus>(
 params: undefined |  MessagesGetNotificationTypesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof messagesGetNotificationTypes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof messagesGetNotificationTypes>>,
          TError,
          Awaited<ReturnType<typeof messagesGetNotificationTypes>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMessagesGetNotificationTypes<TData = Awaited<ReturnType<typeof messagesGetNotificationTypes>>, TError = GooglerpcStatus>(
 params?: MessagesGetNotificationTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof messagesGetNotificationTypes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof messagesGetNotificationTypes>>,
          TError,
          Awaited<ReturnType<typeof messagesGetNotificationTypes>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMessagesGetNotificationTypes<TData = Awaited<ReturnType<typeof messagesGetNotificationTypes>>, TError = GooglerpcStatus>(
 params?: MessagesGetNotificationTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof messagesGetNotificationTypes>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Type list
 */

export function useMessagesGetNotificationTypes<TData = Awaited<ReturnType<typeof messagesGetNotificationTypes>>, TError = GooglerpcStatus>(
 params?: MessagesGetNotificationTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof messagesGetNotificationTypes>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMessagesGetNotificationTypesQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Account requisites
 */
export const reportAccountRequisites = (
    accountId: string,
    params?: ReportAccountRequisitesParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<V1ExportResponse>(
      {url: `/v2/report/account/${accountId}`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getReportAccountRequisitesQueryKey = (accountId?: string,
    params?: ReportAccountRequisitesParams,) => {
    return [
    `/v2/report/account/${accountId}`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getReportAccountRequisitesQueryOptions = <TData = Awaited<ReturnType<typeof reportAccountRequisites>>, TError = GooglerpcStatus>(accountId: string,
    params?: ReportAccountRequisitesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportAccountRequisites>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReportAccountRequisitesQueryKey(accountId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof reportAccountRequisites>>> = ({ signal }) => reportAccountRequisites(accountId,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(accountId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof reportAccountRequisites>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReportAccountRequisitesQueryResult = NonNullable<Awaited<ReturnType<typeof reportAccountRequisites>>>
export type ReportAccountRequisitesQueryError = GooglerpcStatus


export function useReportAccountRequisites<TData = Awaited<ReturnType<typeof reportAccountRequisites>>, TError = GooglerpcStatus>(
 accountId: string,
    params: undefined |  ReportAccountRequisitesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportAccountRequisites>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportAccountRequisites>>,
          TError,
          Awaited<ReturnType<typeof reportAccountRequisites>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReportAccountRequisites<TData = Awaited<ReturnType<typeof reportAccountRequisites>>, TError = GooglerpcStatus>(
 accountId: string,
    params?: ReportAccountRequisitesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportAccountRequisites>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportAccountRequisites>>,
          TError,
          Awaited<ReturnType<typeof reportAccountRequisites>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReportAccountRequisites<TData = Awaited<ReturnType<typeof reportAccountRequisites>>, TError = GooglerpcStatus>(
 accountId: string,
    params?: ReportAccountRequisitesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportAccountRequisites>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Account requisites
 */

export function useReportAccountRequisites<TData = Awaited<ReturnType<typeof reportAccountRequisites>>, TError = GooglerpcStatus>(
 accountId: string,
    params?: ReportAccountRequisitesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportAccountRequisites>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReportAccountRequisitesQueryOptions(accountId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Counterparty account requisites
 */
export const reportCounterpartyAccountRequisites = (
    accountId: string,
    params?: ReportCounterpartyAccountRequisitesParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<V1ExportResponse>(
      {url: `/v2/report/counterparty/account/${accountId}`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getReportCounterpartyAccountRequisitesQueryKey = (accountId?: string,
    params?: ReportCounterpartyAccountRequisitesParams,) => {
    return [
    `/v2/report/counterparty/account/${accountId}`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getReportCounterpartyAccountRequisitesQueryOptions = <TData = Awaited<ReturnType<typeof reportCounterpartyAccountRequisites>>, TError = GooglerpcStatus>(accountId: string,
    params?: ReportCounterpartyAccountRequisitesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportCounterpartyAccountRequisites>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReportCounterpartyAccountRequisitesQueryKey(accountId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof reportCounterpartyAccountRequisites>>> = ({ signal }) => reportCounterpartyAccountRequisites(accountId,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(accountId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof reportCounterpartyAccountRequisites>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReportCounterpartyAccountRequisitesQueryResult = NonNullable<Awaited<ReturnType<typeof reportCounterpartyAccountRequisites>>>
export type ReportCounterpartyAccountRequisitesQueryError = GooglerpcStatus


export function useReportCounterpartyAccountRequisites<TData = Awaited<ReturnType<typeof reportCounterpartyAccountRequisites>>, TError = GooglerpcStatus>(
 accountId: string,
    params: undefined |  ReportCounterpartyAccountRequisitesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportCounterpartyAccountRequisites>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportCounterpartyAccountRequisites>>,
          TError,
          Awaited<ReturnType<typeof reportCounterpartyAccountRequisites>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReportCounterpartyAccountRequisites<TData = Awaited<ReturnType<typeof reportCounterpartyAccountRequisites>>, TError = GooglerpcStatus>(
 accountId: string,
    params?: ReportCounterpartyAccountRequisitesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportCounterpartyAccountRequisites>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportCounterpartyAccountRequisites>>,
          TError,
          Awaited<ReturnType<typeof reportCounterpartyAccountRequisites>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReportCounterpartyAccountRequisites<TData = Awaited<ReturnType<typeof reportCounterpartyAccountRequisites>>, TError = GooglerpcStatus>(
 accountId: string,
    params?: ReportCounterpartyAccountRequisitesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportCounterpartyAccountRequisites>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Counterparty account requisites
 */

export function useReportCounterpartyAccountRequisites<TData = Awaited<ReturnType<typeof reportCounterpartyAccountRequisites>>, TError = GooglerpcStatus>(
 accountId: string,
    params?: ReportCounterpartyAccountRequisitesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportCounterpartyAccountRequisites>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReportCounterpartyAccountRequisitesQueryOptions(accountId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Operations list
 */
export const reportOperationList = (
    params?: ReportOperationListParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<V1ExportResponse>(
      {url: `/v2/report/operations`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getReportOperationListQueryKey = (params?: ReportOperationListParams,) => {
    return [
    `/v2/report/operations`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getReportOperationListQueryOptions = <TData = Awaited<ReturnType<typeof reportOperationList>>, TError = GooglerpcStatus>(params?: ReportOperationListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportOperationList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReportOperationListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof reportOperationList>>> = ({ signal }) => reportOperationList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof reportOperationList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReportOperationListQueryResult = NonNullable<Awaited<ReturnType<typeof reportOperationList>>>
export type ReportOperationListQueryError = GooglerpcStatus


export function useReportOperationList<TData = Awaited<ReturnType<typeof reportOperationList>>, TError = GooglerpcStatus>(
 params: undefined |  ReportOperationListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportOperationList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportOperationList>>,
          TError,
          Awaited<ReturnType<typeof reportOperationList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReportOperationList<TData = Awaited<ReturnType<typeof reportOperationList>>, TError = GooglerpcStatus>(
 params?: ReportOperationListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportOperationList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportOperationList>>,
          TError,
          Awaited<ReturnType<typeof reportOperationList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReportOperationList<TData = Awaited<ReturnType<typeof reportOperationList>>, TError = GooglerpcStatus>(
 params?: ReportOperationListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportOperationList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Operations list
 */

export function useReportOperationList<TData = Awaited<ReturnType<typeof reportOperationList>>, TError = GooglerpcStatus>(
 params?: ReportOperationListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportOperationList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReportOperationListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Operation detail
 */
export const reportOperationDetail = (
    customerId: string,
    operationId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<V1ExportResponse>(
      {url: `/v2/report/operations/${customerId}/${operationId}`, method: 'GET', signal
    },
      );
    }
  



export const getReportOperationDetailQueryKey = (customerId?: string,
    operationId?: string,) => {
    return [
    `/v2/report/operations/${customerId}/${operationId}`
    ] as const;
    }

    
export const getReportOperationDetailQueryOptions = <TData = Awaited<ReturnType<typeof reportOperationDetail>>, TError = GooglerpcStatus>(customerId: string,
    operationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportOperationDetail>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReportOperationDetailQueryKey(customerId,operationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof reportOperationDetail>>> = ({ signal }) => reportOperationDetail(customerId,operationId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(customerId && operationId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof reportOperationDetail>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReportOperationDetailQueryResult = NonNullable<Awaited<ReturnType<typeof reportOperationDetail>>>
export type ReportOperationDetailQueryError = GooglerpcStatus


export function useReportOperationDetail<TData = Awaited<ReturnType<typeof reportOperationDetail>>, TError = GooglerpcStatus>(
 customerId: string,
    operationId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportOperationDetail>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportOperationDetail>>,
          TError,
          Awaited<ReturnType<typeof reportOperationDetail>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReportOperationDetail<TData = Awaited<ReturnType<typeof reportOperationDetail>>, TError = GooglerpcStatus>(
 customerId: string,
    operationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportOperationDetail>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportOperationDetail>>,
          TError,
          Awaited<ReturnType<typeof reportOperationDetail>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReportOperationDetail<TData = Awaited<ReturnType<typeof reportOperationDetail>>, TError = GooglerpcStatus>(
 customerId: string,
    operationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportOperationDetail>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Operation detail
 */

export function useReportOperationDetail<TData = Awaited<ReturnType<typeof reportOperationDetail>>, TError = GooglerpcStatus>(
 customerId: string,
    operationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportOperationDetail>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReportOperationDetailQueryOptions(customerId,operationId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Account statements
 */
export const reportAccountStatement = (
    params?: ReportAccountStatementParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<V1ExportResponse>(
      {url: `/v2/report/statement`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getReportAccountStatementQueryKey = (params?: ReportAccountStatementParams,) => {
    return [
    `/v2/report/statement`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getReportAccountStatementQueryOptions = <TData = Awaited<ReturnType<typeof reportAccountStatement>>, TError = GooglerpcStatus>(params?: ReportAccountStatementParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportAccountStatement>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReportAccountStatementQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof reportAccountStatement>>> = ({ signal }) => reportAccountStatement(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof reportAccountStatement>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReportAccountStatementQueryResult = NonNullable<Awaited<ReturnType<typeof reportAccountStatement>>>
export type ReportAccountStatementQueryError = GooglerpcStatus


export function useReportAccountStatement<TData = Awaited<ReturnType<typeof reportAccountStatement>>, TError = GooglerpcStatus>(
 params: undefined |  ReportAccountStatementParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportAccountStatement>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportAccountStatement>>,
          TError,
          Awaited<ReturnType<typeof reportAccountStatement>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReportAccountStatement<TData = Awaited<ReturnType<typeof reportAccountStatement>>, TError = GooglerpcStatus>(
 params?: ReportAccountStatementParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportAccountStatement>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportAccountStatement>>,
          TError,
          Awaited<ReturnType<typeof reportAccountStatement>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReportAccountStatement<TData = Awaited<ReturnType<typeof reportAccountStatement>>, TError = GooglerpcStatus>(
 params?: ReportAccountStatementParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportAccountStatement>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Account statements
 */

export function useReportAccountStatement<TData = Awaited<ReturnType<typeof reportAccountStatement>>, TError = GooglerpcStatus>(
 params?: ReportAccountStatementParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportAccountStatement>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReportAccountStatementQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Upload document request.<br> Use POST ```multipart/form-data``` content type for send this form
 * @summary Upload File
 */
export const storageUploadDummy = (
    userFileUpload: UserFileUpload,
 signal?: AbortSignal
) => {
      
      
      return customInstance<UserUploadResponse>(
      {url: `/v2/storage`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userFileUpload, signal
    },
      );
    }
  


export const getStorageUploadDummyMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof storageUploadDummy>>, TError,{data: UserFileUpload}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof storageUploadDummy>>, TError,{data: UserFileUpload}, TContext> => {

const mutationKey = ['storageUploadDummy'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof storageUploadDummy>>, {data: UserFileUpload}> = (props) => {
          const {data} = props ?? {};

          return  storageUploadDummy(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type StorageUploadDummyMutationResult = NonNullable<Awaited<ReturnType<typeof storageUploadDummy>>>
    export type StorageUploadDummyMutationBody = UserFileUpload
    export type StorageUploadDummyMutationError = GooglerpcStatus

    /**
 * @summary Upload File
 */
export const useStorageUploadDummy = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof storageUploadDummy>>, TError,{data: UserFileUpload}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof storageUploadDummy>>,
        TError,
        {data: UserFileUpload},
        TContext
      > => {

      const mutationOptions = getStorageUploadDummyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary List Files
 */
export const storageList = (
    params?: StorageListParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<UserFileListRespond>(
      {url: `/v2/storage/file`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getStorageListQueryKey = (params?: StorageListParams,) => {
    return [
    `/v2/storage/file`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getStorageListQueryOptions = <TData = Awaited<ReturnType<typeof storageList>>, TError = GooglerpcStatus>(params?: StorageListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStorageListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof storageList>>> = ({ signal }) => storageList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof storageList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StorageListQueryResult = NonNullable<Awaited<ReturnType<typeof storageList>>>
export type StorageListQueryError = GooglerpcStatus


export function useStorageList<TData = Awaited<ReturnType<typeof storageList>>, TError = GooglerpcStatus>(
 params: undefined |  StorageListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof storageList>>,
          TError,
          Awaited<ReturnType<typeof storageList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStorageList<TData = Awaited<ReturnType<typeof storageList>>, TError = GooglerpcStatus>(
 params?: StorageListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof storageList>>,
          TError,
          Awaited<ReturnType<typeof storageList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStorageList<TData = Awaited<ReturnType<typeof storageList>>, TError = GooglerpcStatus>(
 params?: StorageListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Files
 */

export function useStorageList<TData = Awaited<ReturnType<typeof storageList>>, TError = GooglerpcStatus>(
 params?: StorageListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStorageListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Download document.<br> Return raw file content with mimetype header of document
 * @summary Download File
 */
export const storageDownload = (
    id: string,
    params?: StorageDownloadParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ApiHttpBody>(
      {url: `/v2/storage/file/${id}`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getStorageDownloadQueryKey = (id?: string,
    params?: StorageDownloadParams,) => {
    return [
    `/v2/storage/file/${id}`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getStorageDownloadQueryOptions = <TData = Awaited<ReturnType<typeof storageDownload>>, TError = GooglerpcStatus>(id: string,
    params?: StorageDownloadParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageDownload>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStorageDownloadQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof storageDownload>>> = ({ signal }) => storageDownload(id,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof storageDownload>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StorageDownloadQueryResult = NonNullable<Awaited<ReturnType<typeof storageDownload>>>
export type StorageDownloadQueryError = GooglerpcStatus


export function useStorageDownload<TData = Awaited<ReturnType<typeof storageDownload>>, TError = GooglerpcStatus>(
 id: string,
    params: undefined |  StorageDownloadParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageDownload>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof storageDownload>>,
          TError,
          Awaited<ReturnType<typeof storageDownload>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStorageDownload<TData = Awaited<ReturnType<typeof storageDownload>>, TError = GooglerpcStatus>(
 id: string,
    params?: StorageDownloadParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageDownload>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof storageDownload>>,
          TError,
          Awaited<ReturnType<typeof storageDownload>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStorageDownload<TData = Awaited<ReturnType<typeof storageDownload>>, TError = GooglerpcStatus>(
 id: string,
    params?: StorageDownloadParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageDownload>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Download File
 */

export function useStorageDownload<TData = Awaited<ReturnType<typeof storageDownload>>, TError = GooglerpcStatus>(
 id: string,
    params?: StorageDownloadParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageDownload>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStorageDownloadQueryOptions(id,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Remove document.
 * @summary Delete File
 */
export const storageDelete = (
    id: string,
    params?: StorageDeleteParams,
 ) => {
      
      
      return customInstance<V2RespondStatus>(
      {url: `/v2/storage/file/${id}`, method: 'DELETE',
        params
    },
      );
    }
  


export const getStorageDeleteMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof storageDelete>>, TError,{id: string;params?: StorageDeleteParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof storageDelete>>, TError,{id: string;params?: StorageDeleteParams}, TContext> => {

const mutationKey = ['storageDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof storageDelete>>, {id: string;params?: StorageDeleteParams}> = (props) => {
          const {id,params} = props ?? {};

          return  storageDelete(id,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type StorageDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof storageDelete>>>
    
    export type StorageDeleteMutationError = GooglerpcStatus

    /**
 * @summary Delete File
 */
export const useStorageDelete = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof storageDelete>>, TError,{id: string;params?: StorageDeleteParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof storageDelete>>,
        TError,
        {id: string;params?: StorageDeleteParams},
        TContext
      > => {

      const mutationOptions = getStorageDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary List Users
 */
export const usersList = (
    params?: UsersListParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<UserListUserRespond>(
      {url: `/v2/user`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getUsersListQueryKey = (params?: UsersListParams,) => {
    return [
    `/v2/user`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getUsersListQueryOptions = <TData = Awaited<ReturnType<typeof usersList>>, TError = GooglerpcStatus>(params?: UsersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsersListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersList>>> = ({ signal }) => usersList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsersListQueryResult = NonNullable<Awaited<ReturnType<typeof usersList>>>
export type UsersListQueryError = GooglerpcStatus


export function useUsersList<TData = Awaited<ReturnType<typeof usersList>>, TError = GooglerpcStatus>(
 params: undefined |  UsersListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersList>>,
          TError,
          Awaited<ReturnType<typeof usersList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersList<TData = Awaited<ReturnType<typeof usersList>>, TError = GooglerpcStatus>(
 params?: UsersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersList>>,
          TError,
          Awaited<ReturnType<typeof usersList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersList<TData = Awaited<ReturnType<typeof usersList>>, TError = GooglerpcStatus>(
 params?: UsersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Users
 */

export function useUsersList<TData = Awaited<ReturnType<typeof usersList>>, TError = GooglerpcStatus>(
 params?: UsersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUsersListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Add User
 */
export const usersAdd = (
    userCreateUserRequest: UserCreateUserRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<UserUserRespond>(
      {url: `/v2/user`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userCreateUserRequest, signal
    },
      );
    }
  


export const getUsersAddMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersAdd>>, TError,{data: UserCreateUserRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof usersAdd>>, TError,{data: UserCreateUserRequest}, TContext> => {

const mutationKey = ['usersAdd'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersAdd>>, {data: UserCreateUserRequest}> = (props) => {
          const {data} = props ?? {};

          return  usersAdd(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersAddMutationResult = NonNullable<Awaited<ReturnType<typeof usersAdd>>>
    export type UsersAddMutationBody = UserCreateUserRequest
    export type UsersAddMutationError = GooglerpcStatus

    /**
 * @summary Add User
 */
export const useUsersAdd = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersAdd>>, TError,{data: UserCreateUserRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersAdd>>,
        TError,
        {data: UserCreateUserRequest},
        TContext
      > => {

      const mutationOptions = getUsersAddMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get User
 */
export const usersGet = (
    userId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<UserGetUserRespond>(
      {url: `/v2/user/${userId}`, method: 'GET', signal
    },
      );
    }
  



export const getUsersGetQueryKey = (userId?: string,) => {
    return [
    `/v2/user/${userId}`
    ] as const;
    }

    
export const getUsersGetQueryOptions = <TData = Awaited<ReturnType<typeof usersGet>>, TError = GooglerpcStatus>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsersGetQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersGet>>> = ({ signal }) => usersGet(userId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsersGetQueryResult = NonNullable<Awaited<ReturnType<typeof usersGet>>>
export type UsersGetQueryError = GooglerpcStatus


export function useUsersGet<TData = Awaited<ReturnType<typeof usersGet>>, TError = GooglerpcStatus>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersGet>>,
          TError,
          Awaited<ReturnType<typeof usersGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersGet<TData = Awaited<ReturnType<typeof usersGet>>, TError = GooglerpcStatus>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersGet>>,
          TError,
          Awaited<ReturnType<typeof usersGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersGet<TData = Awaited<ReturnType<typeof usersGet>>, TError = GooglerpcStatus>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get User
 */

export function useUsersGet<TData = Awaited<ReturnType<typeof usersGet>>, TError = GooglerpcStatus>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUsersGetQueryOptions(userId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Delete User
 */
export const usersDelete = (
    userId: string,
    params?: UsersDeleteParams,
 ) => {
      
      
      return customInstance<V2RespondStatus>(
      {url: `/v2/user/${userId}`, method: 'DELETE',
        params
    },
      );
    }
  


export const getUsersDeleteMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersDelete>>, TError,{userId: string;params?: UsersDeleteParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof usersDelete>>, TError,{userId: string;params?: UsersDeleteParams}, TContext> => {

const mutationKey = ['usersDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersDelete>>, {userId: string;params?: UsersDeleteParams}> = (props) => {
          const {userId,params} = props ?? {};

          return  usersDelete(userId,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof usersDelete>>>
    
    export type UsersDeleteMutationError = GooglerpcStatus

    /**
 * @summary Delete User
 */
export const useUsersDelete = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersDelete>>, TError,{userId: string;params?: UsersDeleteParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersDelete>>,
        TError,
        {userId: string;params?: UsersDeleteParams},
        TContext
      > => {

      const mutationOptions = getUsersDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Update User
 */
export const usersUpdate = (
    userId: string,
    userUsersUpdateBody: UserUsersUpdateBody,
 ) => {
      
      
      return customInstance<UserUserRespond>(
      {url: `/v2/user/${userId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: userUsersUpdateBody
    },
      );
    }
  


export const getUsersUpdateMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersUpdate>>, TError,{userId: string;data: UserUsersUpdateBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof usersUpdate>>, TError,{userId: string;data: UserUsersUpdateBody}, TContext> => {

const mutationKey = ['usersUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersUpdate>>, {userId: string;data: UserUsersUpdateBody}> = (props) => {
          const {userId,data} = props ?? {};

          return  usersUpdate(userId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof usersUpdate>>>
    export type UsersUpdateMutationBody = UserUsersUpdateBody
    export type UsersUpdateMutationError = GooglerpcStatus

    /**
 * @summary Update User
 */
export const useUsersUpdate = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersUpdate>>, TError,{userId: string;data: UserUsersUpdateBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersUpdate>>,
        TError,
        {userId: string;data: UserUsersUpdateBody},
        TContext
      > => {

      const mutationOptions = getUsersUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Bind Client
 */
export const usersAddRelationClient = (
    userId: string,
    usersAddRelationClientBody: UsersAddRelationClientBody,
 ) => {
      
      
      return customInstance<UserUserRespond>(
      {url: `/v2/user/${userId}/relate-customer`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: usersAddRelationClientBody
    },
      );
    }
  


export const getUsersAddRelationClientMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersAddRelationClient>>, TError,{userId: string;data: UsersAddRelationClientBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof usersAddRelationClient>>, TError,{userId: string;data: UsersAddRelationClientBody}, TContext> => {

const mutationKey = ['usersAddRelationClient'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersAddRelationClient>>, {userId: string;data: UsersAddRelationClientBody}> = (props) => {
          const {userId,data} = props ?? {};

          return  usersAddRelationClient(userId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersAddRelationClientMutationResult = NonNullable<Awaited<ReturnType<typeof usersAddRelationClient>>>
    export type UsersAddRelationClientMutationBody = UsersAddRelationClientBody
    export type UsersAddRelationClientMutationError = GooglerpcStatus

    /**
 * @summary Bind Client
 */
export const useUsersAddRelationClient = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersAddRelationClient>>, TError,{userId: string;data: UsersAddRelationClientBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersAddRelationClient>>,
        TError,
        {userId: string;data: UsersAddRelationClientBody},
        TContext
      > => {

      const mutationOptions = getUsersAddRelationClientMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Remove Bind Client
 */
export const usersRemoveRelationClient = (
    userId: string,
    customerId: string,
    params?: UsersRemoveRelationClientParams,
 ) => {
      
      
      return customInstance<UserUserRespond>(
      {url: `/v2/user/${userId}/relate-customer/${customerId}`, method: 'DELETE',
        params
    },
      );
    }
  


export const getUsersRemoveRelationClientMutationOptions = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersRemoveRelationClient>>, TError,{userId: string;customerId: string;params?: UsersRemoveRelationClientParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof usersRemoveRelationClient>>, TError,{userId: string;customerId: string;params?: UsersRemoveRelationClientParams}, TContext> => {

const mutationKey = ['usersRemoveRelationClient'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersRemoveRelationClient>>, {userId: string;customerId: string;params?: UsersRemoveRelationClientParams}> = (props) => {
          const {userId,customerId,params} = props ?? {};

          return  usersRemoveRelationClient(userId,customerId,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersRemoveRelationClientMutationResult = NonNullable<Awaited<ReturnType<typeof usersRemoveRelationClient>>>
    
    export type UsersRemoveRelationClientMutationError = GooglerpcStatus

    /**
 * @summary Remove Bind Client
 */
export const useUsersRemoveRelationClient = <TError = GooglerpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersRemoveRelationClient>>, TError,{userId: string;customerId: string;params?: UsersRemoveRelationClientParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersRemoveRelationClient>>,
        TError,
        {userId: string;customerId: string;params?: UsersRemoveRelationClientParams},
        TContext
      > => {

      const mutationOptions = getUsersRemoveRelationClientMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
